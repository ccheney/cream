/**
 * Multi-Agent Orchestration Framework
 *
 * Implements coordination utilities for the trader → risk → critic pipeline.
 * Provides timeout handling, error propagation, and consensus validation.
 *
 * @see docs/plans/14-testing.md lines 478-517
 */

import type { AgentType } from "../../src/index.js";

/**
 * Decision plan generated by trader agent.
 */
export interface DecisionPlan {
  /** Unique plan identifier */
  id: string;

  /** Symbol being traded */
  symbol: string;

  /** Action to take */
  action: "BUY" | "SELL" | "HOLD" | "CLOSE";

  /** Position direction */
  direction: "LONG" | "SHORT" | "FLAT";

  /** Position size */
  size: {
    quantity: number;
    unit: "SHARES" | "CONTRACTS" | "DOLLARS" | "PCT_EQUITY";
  };

  /** Stop loss price */
  stopLoss: number;

  /** Take profit price */
  takeProfit: number;

  /** Confidence score 0-1 */
  confidence: number;

  /** Rationale for the decision */
  rationale: string;

  /** Timestamp */
  timestamp: string;
}

/**
 * Market snapshot for agent input.
 */
export interface Snapshot {
  /** Unique snapshot identifier */
  id: string;

  /** Symbol being analyzed */
  symbol: string;

  /** Current price */
  price: number;

  /** Technical indicators */
  indicators: {
    sma20: number;
    sma50: number;
    rsi: number;
    atr: number;
  };

  /** Complexity level for testing */
  complexity?: "simple" | "moderate" | "extreme";

  /** Timestamp */
  timestamp: string;
}

/**
 * Risk manager validation result.
 */
export interface RiskResult {
  /** Verdict */
  verdict: "APPROVE" | "REJECT";

  /** The plan that was passed through */
  planPassedThrough: DecisionPlan;

  /** Approved plan (only if verdict is APPROVE) */
  approvedPlan?: DecisionPlan;

  /** Rejection reason (only if verdict is REJECT) */
  rejectionReason?: string;

  /** Risk metrics */
  metrics: {
    positionSizeOk: boolean;
    stopLossOk: boolean;
    portfolioRiskOk: boolean;
  };
}

/**
 * Critic agent review result.
 */
export interface CriticResult {
  /** Verdict */
  verdict: "APPROVE" | "REJECT";

  /** Original plan ID from trader */
  originalPlanId: string;

  /** Review score 0-1 */
  score: number;

  /** Issues found */
  issues: string[];

  /** Suggestions for improvement */
  suggestions: string[];
}

/**
 * Pipeline execution status.
 */
export type PipelineStatus =
  | "COMPLETE"
  | "SKIP"
  | "TRADER_FAILED"
  | "RISK_REJECTED"
  | "CRITIC_REJECTED"
  | "TIMEOUT";

/**
 * Pipeline execution result.
 */
export interface PipelineResult {
  /** Execution status */
  status: PipelineStatus;

  /** Final decision plan (if approved) */
  plan?: DecisionPlan;

  /** Trader result */
  traderResult?: DecisionPlan;

  /** Risk result */
  riskResult?: RiskResult;

  /** Critic result */
  criticResult?: CriticResult;

  /** Error if any */
  error?: Error;

  /** Execution time in ms */
  executionTimeMs: number;
}

/**
 * Agent interface for orchestration.
 */
export interface Agent<TInput, TOutput> {
  /** Agent name */
  name: AgentType;

  /** Agent version */
  version: string;

  /** Run the agent */
  run: (input: TInput) => Promise<TOutput>;
}

/**
 * Timeout options.
 */
export interface TimeoutOptions<T> {
  /** Fallback value on timeout */
  fallback: T | "SKIP";

  /** Callback on timeout */
  onTimeout?: () => void;
}

/**
 * Execute a promise with timeout.
 * Returns fallback value if timeout is exceeded.
 * Errors are propagated, not caught.
 */
export async function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number,
  options: TimeoutOptions<T>
): Promise<{ value: T; status: "COMPLETE" | "SKIP" }> {
  return new Promise((resolve, reject) => {
    let timedOut = false;

    const timer = setTimeout(() => {
      timedOut = true;
      options.onTimeout?.();
      if (options.fallback === "SKIP") {
        resolve({ value: undefined as unknown as T, status: "SKIP" });
      } else {
        resolve({ value: options.fallback, status: "SKIP" });
      }
    }, timeoutMs);

    promise
      .then((value) => {
        if (!timedOut) {
          clearTimeout(timer);
          resolve({ value, status: "COMPLETE" });
        }
      })
      .catch((error) => {
        if (!timedOut) {
          clearTimeout(timer);
          reject(error);
        }
      });
  });
}

/**
 * Create a mock trader agent.
 */
export function createMockTraderAgent(options?: {
  delay?: number;
  shouldFail?: boolean;
  failureMessage?: string;
}): Agent<Snapshot, DecisionPlan> {
  return {
    name: "trader",
    version: "1.0.0",
    run: async (snapshot: Snapshot): Promise<DecisionPlan> => {
      if (options?.delay) {
        await new Promise((resolve) => setTimeout(resolve, options.delay));
      }

      if (options?.shouldFail) {
        throw new Error(options.failureMessage ?? "Trader agent failed");
      }

      const isBullish = snapshot.price > snapshot.indicators.sma20;

      return {
        id: `plan-${snapshot.id}`,
        symbol: snapshot.symbol,
        action: isBullish ? "BUY" : "SELL",
        direction: isBullish ? "LONG" : "SHORT",
        size: {
          quantity: 100,
          unit: "SHARES",
        },
        stopLoss: isBullish
          ? snapshot.price - snapshot.indicators.atr * 2
          : snapshot.price + snapshot.indicators.atr * 2,
        takeProfit: isBullish
          ? snapshot.price + snapshot.indicators.atr * 4
          : snapshot.price - snapshot.indicators.atr * 4,
        confidence: 0.75,
        rationale: isBullish
          ? "Price above SMA20, bullish momentum"
          : "Price below SMA20, bearish momentum",
        timestamp: new Date().toISOString(),
      };
    },
  };
}

/**
 * Create a mock risk manager agent.
 */
export function createMockRiskManagerAgent(options?: {
  delay?: number;
  shouldFail?: boolean;
  shouldReject?: boolean;
  rejectionReason?: string;
}): Agent<{ plan: DecisionPlan; snapshot: Snapshot }, RiskResult> {
  return {
    name: "risk_manager",
    version: "1.0.0",
    run: async ({
      plan,
      snapshot,
    }: {
      plan: DecisionPlan;
      snapshot: Snapshot;
    }): Promise<RiskResult> => {
      if (options?.delay) {
        await new Promise((resolve) => setTimeout(resolve, options.delay));
      }

      if (options?.shouldFail) {
        throw new Error("Risk manager agent failed");
      }

      const positionSizeOk = plan.size.quantity <= 1000;
      const stopLossOk = Math.abs(plan.stopLoss - snapshot.price) < snapshot.price * 0.1;
      const portfolioRiskOk = true;

      const allOk = positionSizeOk && stopLossOk && portfolioRiskOk;

      if (options?.shouldReject || !allOk) {
        return {
          verdict: "REJECT",
          planPassedThrough: plan,
          rejectionReason:
            options?.rejectionReason ??
            (!positionSizeOk
              ? "Position size too large"
              : !stopLossOk
                ? "Stop loss too far"
                : "Portfolio risk exceeded"),
          metrics: {
            positionSizeOk,
            stopLossOk,
            portfolioRiskOk,
          },
        };
      }

      return {
        verdict: "APPROVE",
        planPassedThrough: plan,
        approvedPlan: plan,
        metrics: {
          positionSizeOk,
          stopLossOk,
          portfolioRiskOk,
        },
      };
    },
  };
}

/**
 * Create a mock critic agent.
 */
export function createMockCriticAgent(options?: {
  delay?: number;
  shouldFail?: boolean;
  shouldReject?: boolean;
  rejectionIssues?: string[];
}): Agent<{ plan: DecisionPlan; snapshot: Snapshot }, CriticResult> {
  return {
    name: "critic",
    version: "1.0.0",
    run: async ({ plan }: { plan: DecisionPlan; snapshot: Snapshot }): Promise<CriticResult> => {
      if (options?.delay) {
        await new Promise((resolve) => setTimeout(resolve, options.delay));
      }

      if (options?.shouldFail) {
        throw new Error("Critic agent failed");
      }

      const issues: string[] = [];

      if (plan.action === "BUY" && plan.rationale.toLowerCase().includes("bearish")) {
        issues.push("Inconsistent: BUY action with bearish rationale");
      }
      if (plan.action === "SELL" && plan.rationale.toLowerCase().includes("bullish")) {
        issues.push("Inconsistent: SELL action with bullish rationale");
      }

      if (options?.shouldReject) {
        return {
          verdict: "REJECT",
          originalPlanId: plan.id,
          score: 0.4,
          issues: options.rejectionIssues ?? ["Forced rejection for testing"],
          suggestions: ["Review the analysis"],
        };
      }

      if (issues.length > 0) {
        return {
          verdict: "REJECT",
          originalPlanId: plan.id,
          score: 0.5,
          issues,
          suggestions: ["Fix logical inconsistencies"],
        };
      }

      return {
        verdict: "APPROVE",
        originalPlanId: plan.id,
        score: 0.85,
        issues: [],
        suggestions: [],
      };
    },
  };
}

/**
 * Execute the full trading pipeline: trader → risk → critic.
 */
export async function executePipeline(
  snapshot: Snapshot,
  traderAgent: Agent<Snapshot, DecisionPlan>,
  riskAgent: Agent<{ plan: DecisionPlan; snapshot: Snapshot }, RiskResult>,
  criticAgent: Agent<{ plan: DecisionPlan; snapshot: Snapshot }, CriticResult>,
  options?: {
    timeoutMs?: number;
    stopOnRiskReject?: boolean;
  }
): Promise<PipelineResult> {
  const startTime = Date.now();
  const timeoutMs = options?.timeoutMs ?? 30000;
  const stopOnRiskReject = options?.stopOnRiskReject ?? true;

  try {
    const traderResult = await withTimeout(traderAgent.run(snapshot), timeoutMs, {
      fallback: "SKIP",
    });

    if (traderResult.status === "SKIP") {
      return {
        status: "TIMEOUT",
        executionTimeMs: Date.now() - startTime,
      };
    }

    const plan = traderResult.value;

    const riskResult = await withTimeout(riskAgent.run({ plan, snapshot }), timeoutMs, {
      fallback: "SKIP",
    });

    if (riskResult.status === "SKIP") {
      return {
        status: "TIMEOUT",
        traderResult: plan,
        executionTimeMs: Date.now() - startTime,
      };
    }

    if (riskResult.value.verdict === "REJECT" && stopOnRiskReject) {
      return {
        status: "RISK_REJECTED",
        traderResult: plan,
        riskResult: riskResult.value,
        executionTimeMs: Date.now() - startTime,
      };
    }

    const approvedPlan = riskResult.value.approvedPlan ?? plan;
    const criticResult = await withTimeout(
      criticAgent.run({ plan: approvedPlan, snapshot }),
      timeoutMs,
      { fallback: "SKIP" }
    );

    if (criticResult.status === "SKIP") {
      return {
        status: "TIMEOUT",
        traderResult: plan,
        riskResult: riskResult.value,
        executionTimeMs: Date.now() - startTime,
      };
    }

    if (criticResult.value.verdict === "REJECT") {
      return {
        status: "CRITIC_REJECTED",
        traderResult: plan,
        riskResult: riskResult.value,
        criticResult: criticResult.value,
        executionTimeMs: Date.now() - startTime,
      };
    }

    return {
      status: "COMPLETE",
      plan: approvedPlan,
      traderResult: plan,
      riskResult: riskResult.value,
      criticResult: criticResult.value,
      executionTimeMs: Date.now() - startTime,
    };
  } catch (error) {
    return {
      status: "TRADER_FAILED",
      error: error as Error,
      executionTimeMs: Date.now() - startTime,
    };
  }
}

/**
 * Create a test snapshot.
 */
export function createTestSnapshot(options?: {
  symbol?: string;
  price?: number;
  bullish?: boolean;
  complexity?: "simple" | "moderate" | "extreme";
}): Snapshot {
  const price = options?.price ?? 100;
  const isBullish = options?.bullish ?? true;

  return {
    id: `snapshot-${Date.now()}`,
    symbol: options?.symbol ?? "AAPL",
    price,
    indicators: {
      sma20: isBullish ? price * 0.95 : price * 1.05,
      sma50: isBullish ? price * 0.9 : price * 1.1,
      rsi: isBullish ? 65 : 35,
      atr: price * 0.02, // 2% ATR
    },
    complexity: options?.complexity ?? "simple",
    timestamp: new Date().toISOString(),
  };
}

/**
 * Validate a decision plan has required fields.
 */
export function validateDecisionPlan(plan: unknown): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  if (!plan || typeof plan !== "object") {
    return { valid: false, errors: ["Plan is not an object"] };
  }

  const p = plan as Record<string, unknown>;

  if (!p.id || typeof p.id !== "string") {
    errors.push("Missing or invalid id");
  }
  if (!p.symbol || typeof p.symbol !== "string") {
    errors.push("Missing or invalid symbol");
  }
  if (!["BUY", "SELL", "HOLD", "CLOSE"].includes(p.action as string)) {
    errors.push("Invalid action");
  }
  if (!["LONG", "SHORT", "FLAT"].includes(p.direction as string)) {
    errors.push("Invalid direction");
  }
  if (!p.size || typeof p.size !== "object") {
    errors.push("Missing size");
  }
  if (typeof p.stopLoss !== "number") {
    errors.push("Missing stopLoss");
  }
  if (typeof p.takeProfit !== "number") {
    errors.push("Missing takeProfit");
  }
  if (typeof p.confidence !== "number" || p.confidence < 0 || p.confidence > 1) {
    errors.push("Invalid confidence");
  }
  if (!p.rationale || typeof p.rationale !== "string") {
    errors.push("Missing rationale");
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Verify handoff data integrity (no data loss or corruption).
 */
export function verifyHandoffIntegrity(
  original: DecisionPlan,
  received: DecisionPlan
): { intact: boolean; differences: string[] } {
  const differences: string[] = [];

  if (original.id !== received.id) {
    differences.push("id changed");
  }
  if (original.symbol !== received.symbol) {
    differences.push("symbol changed");
  }
  if (original.action !== received.action) {
    differences.push("action changed");
  }
  if (original.direction !== received.direction) {
    differences.push("direction changed");
  }
  if (original.size.quantity !== received.size.quantity) {
    differences.push("size.quantity changed");
  }
  if (original.size.unit !== received.size.unit) {
    differences.push("size.unit changed");
  }
  if (original.stopLoss !== received.stopLoss) {
    differences.push("stopLoss changed");
  }
  if (original.takeProfit !== received.takeProfit) {
    differences.push("takeProfit changed");
  }
  if (original.confidence !== received.confidence) {
    differences.push("confidence changed");
  }
  if (original.rationale !== received.rationale) {
    differences.push("rationale changed");
  }

  return { intact: differences.length === 0, differences };
}

export default {
  withTimeout,
  createMockTraderAgent,
  createMockRiskManagerAgent,
  createMockCriticAgent,
  executePipeline,
  createTestSnapshot,
  validateDecisionPlan,
  verifyHandoffIntegrity,
};
