/**
 * Indicator Hypothesis Schema
 *
 * Defines the structure for indicator hypotheses generated by the
 * Indicator Researcher agent during the dynamic indicator synthesis process.
 *
 * @see docs/plans/19-dynamic-indicator-synthesis.md (lines 276-343)
 */

import { z } from "zod";

// ============================================
// Hypothesis Categories
// ============================================

/**
 * Valid indicator categories for hypothesis classification
 */
export const HYPOTHESIS_CATEGORIES = [
  "momentum",
  "trend",
  "volatility",
  "volume",
  "correlation",
  "regime",
  "microstructure",
] as const;

export type HypothesisCategory = (typeof HYPOTHESIS_CATEGORIES)[number];

/**
 * Valid timeframes for indicator targeting
 */
export const HYPOTHESIS_TIMEFRAMES = ["1h", "4h", "1d", "1w"] as const;

export type HypothesisTimeframe = (typeof HYPOTHESIS_TIMEFRAMES)[number];

// ============================================
// Hypothesis Schema
// ============================================

/**
 * Schema for expected indicator properties
 */
export const ExpectedPropertiesSchema = z.object({
  /** Expected IC range [min, max] for this indicator */
  expectedICRange: z.tuple([z.number().min(-1).max(1), z.number().min(-1).max(1)]),

  /** Maximum acceptable correlation with existing indicators */
  maxCorrelationWithExisting: z.number().min(0).max(0.5),

  /** Target timeframe for indicator calculation */
  targetTimeframe: z.enum(HYPOTHESIS_TIMEFRAMES),

  /** Market regimes where this indicator should be most effective */
  applicableRegimes: z.array(z.string()).min(1),
});

export type ExpectedProperties = z.infer<typeof ExpectedPropertiesSchema>;

/**
 * Schema for indicator hypothesis output from the Researcher agent
 */
export const IndicatorHypothesisSchema = z.object({
  /** Proposed indicator name (snake_case, descriptive) */
  name: z
    .string()
    .min(3)
    .max(50)
    .regex(/^[a-z][a-z0-9_]*$/, "Name must be snake_case"),

  /** Indicator category classification */
  category: z.enum(HYPOTHESIS_CATEGORIES),

  /** Clear hypothesis statement of what the indicator measures */
  hypothesis: z.string().min(50).max(500),

  /** Economic reasoning for why this indicator should predict returns */
  economicRationale: z.string().min(100).max(1000),

  /** High-level mathematical approach (NOT code) */
  mathematicalApproach: z.string().min(50).max(500),

  /** Falsifiable criteria that would invalidate this hypothesis */
  falsificationCriteria: z.array(z.string().min(10)).min(1).max(5),

  /** Expected quantitative properties */
  expectedProperties: ExpectedPropertiesSchema,

  /** Optional references to academic/practitioner literature */
  relatedAcademicWork: z.array(z.string()).optional(),
});

export type IndicatorHypothesis = z.infer<typeof IndicatorHypothesisSchema>;

// ============================================
// Hypothesis Status Schema
// ============================================

/**
 * Status of a hypothesis in the synthesis pipeline
 */
export const HYPOTHESIS_STATUSES = [
  "proposed", // Initial state from Researcher
  "approved", // Approved for implementation
  "implementing", // Developer agent working on it
  "validating", // Running validation pipeline
  "validated", // Passed validation, ready for paper trading
  "paper_trading", // In paper trading phase
  "promoted", // Promoted to production
  "rejected", // Rejected at any stage
  "retired", // Previously active, now retired
] as const;

export type HypothesisStatus = (typeof HYPOTHESIS_STATUSES)[number];

/**
 * Schema for tracking hypothesis through the synthesis lifecycle
 */
export const HypothesisRecordSchema = z.object({
  /** Unique hypothesis ID */
  id: z.string().uuid(),

  /** The hypothesis content */
  hypothesis: IndicatorHypothesisSchema,

  /** Current status in pipeline */
  status: z.enum(HYPOTHESIS_STATUSES),

  /** Regime that triggered this hypothesis */
  triggeringRegime: z.string(),

  /** Details about why generation was triggered */
  triggerReason: z.string(),

  /** ISO timestamp when hypothesis was created */
  createdAt: z.string().datetime(),

  /** ISO timestamp of last status update */
  updatedAt: z.string().datetime(),

  /** Rejection reason if status is 'rejected' */
  rejectionReason: z.string().optional(),

  /** Validation results if available */
  validationSummary: z
    .object({
      icPassed: z.boolean(),
      dsrPassed: z.boolean(),
      orthogonalityPassed: z.boolean(),
      walkForwardPassed: z.boolean(),
      pboPassed: z.boolean(),
    })
    .optional(),

  /** Implementation file path if implemented */
  implementationPath: z.string().optional(),
});

export type HypothesisRecord = z.infer<typeof HypothesisRecordSchema>;

// ============================================
// Validation Helpers
// ============================================

/**
 * Validate an indicator hypothesis against the schema
 *
 * @param hypothesis - Raw hypothesis data to validate
 * @returns Parsed hypothesis or throws ZodError
 */
export function validateHypothesis(hypothesis: unknown): IndicatorHypothesis {
  return IndicatorHypothesisSchema.parse(hypothesis);
}

/**
 * Safely validate a hypothesis, returning result object
 *
 * @param hypothesis - Raw hypothesis data to validate
 * @returns Success with data or failure with errors
 */
export function safeValidateHypothesis(hypothesis: unknown) {
  return IndicatorHypothesisSchema.safeParse(hypothesis);
}

/**
 * Check if a hypothesis name is valid
 *
 * @param name - Proposed indicator name
 * @returns Whether the name follows conventions
 */
export function isValidHypothesisName(name: string): boolean {
  return /^[a-z][a-z0-9_]*$/.test(name) && name.length >= 3 && name.length <= 50;
}

/**
 * Check if a hypothesis category is valid
 *
 * @param category - Category string to check
 * @returns Type guard for HypothesisCategory
 */
export function isValidCategory(category: string): category is HypothesisCategory {
  return HYPOTHESIS_CATEGORIES.includes(category as HypothesisCategory);
}
