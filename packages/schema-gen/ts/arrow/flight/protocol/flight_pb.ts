// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// Arrow Flight protocol definition (simplified for TypeScript client)

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,import_extension=js"
// @generated from file arrow/flight/protocol/flight.proto (package arrow.flight.protocol, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file arrow/flight/protocol/flight.proto.
 */
export const file_arrow_flight_protocol_flight: GenFile = /*@__PURE__*/
  fileDesc("CiJhcnJvdy9mbGlnaHQvcHJvdG9jb2wvZmxpZ2h0LnByb3RvEhVhcnJvdy5mbGlnaHQucHJvdG9jb2wiPQoQSGFuZHNoYWtlUmVxdWVzdBIYChBwcm90b2NvbF92ZXJzaW9uGAEgASgEEg8KB3BheWxvYWQYAiABKAwiPgoRSGFuZHNoYWtlUmVzcG9uc2USGAoQcHJvdG9jb2xfdmVyc2lvbhgBIAEoBBIPCgdwYXlsb2FkGAIgASgMIi8KCUJhc2ljQXV0aBIQCgh1c2VybmFtZRgCIAEoCRIQCghwYXNzd29yZBgDIAEoCSIHCgVFbXB0eSIvCgpBY3Rpb25UeXBlEgwKBHR5cGUYASABKAkSEwoLZGVzY3JpcHRpb24YAiABKAkiHgoIQ3JpdGVyaWESEgoKZXhwcmVzc2lvbhgBIAEoDCIkCgZBY3Rpb24SDAoEdHlwZRgBIAEoCRIMCgRib2R5GAIgASgMIhYKBlJlc3VsdBIMCgRib2R5GAEgASgMIh4KDFNjaGVtYVJlc3VsdBIOCgZzY2hlbWEYASABKAwipQEKEEZsaWdodERlc2NyaXB0b3ISRAoEdHlwZRgBIAEoDjI2LmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yLkRlc2NyaXB0b3JUeXBlEgsKA2NtZBgCIAEoDBIMCgRwYXRoGAMgAygJIjAKDkRlc2NyaXB0b3JUeXBlEgsKB1VOS05PV04QABIICgRQQVRIEAESBwoDQ01EEAIi7AEKCkZsaWdodEluZm8SDgoGc2NoZW1hGAEgASgMEkIKEWZsaWdodF9kZXNjcmlwdG9yGAIgASgLMicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERlc2NyaXB0b3ISNwoIZW5kcG9pbnQYAyADKAsyJS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RW5kcG9pbnQSFQoNdG90YWxfcmVjb3JkcxgEIAEoAxITCgt0b3RhbF9ieXRlcxgFIAEoAxIPCgdvcmRlcmVkGAYgASgIEhQKDGFwcF9tZXRhZGF0YRgHIAEoDCLVAQoIUG9sbEluZm8SLwoEaW5mbxgBIAEoCzIhLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHRJbmZvEkIKEWZsaWdodF9kZXNjcmlwdG9yGAIgASgLMicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERlc2NyaXB0b3ISFQoIcHJvZ3Jlc3MYAyABKAFIAIgBARIcCg9leHBpcmF0aW9uX3RpbWUYBCABKANIAYgBAUILCglfcHJvZ3Jlc3NCEgoQX2V4cGlyYXRpb25fdGltZSK6AQoORmxpZ2h0RW5kcG9pbnQSLQoGdGlja2V0GAEgASgLMh0uYXJyb3cuZmxpZ2h0LnByb3RvY29sLlRpY2tldBIxCghsb2NhdGlvbhgCIAMoCzIfLmFycm93LmZsaWdodC5wcm90b2NvbC5Mb2NhdGlvbhIcCg9leHBpcmF0aW9uX3RpbWUYAyABKANIAIgBARIUCgxhcHBfbWV0YWRhdGEYBCABKAxCEgoQX2V4cGlyYXRpb25fdGltZSIXCghMb2NhdGlvbhILCgN1cmkYASABKAkiGAoGVGlja2V0Eg4KBnRpY2tldBgBIAEoDCKPAQoKRmxpZ2h0RGF0YRJCChFmbGlnaHRfZGVzY3JpcHRvchgBIAEoCzInLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yEhMKC2RhdGFfaGVhZGVyGAIgASgMEhQKDGFwcF9tZXRhZGF0YRgDIAEoDBISCglkYXRhX2JvZHkY6AcgASgMIiEKCVB1dFJlc3VsdBIUCgxhcHBfbWV0YWRhdGEYASABKAwy8QYKDUZsaWdodFNlcnZpY2USYgoJSGFuZHNoYWtlEicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkhhbmRzaGFrZVJlcXVlc3QaKC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuSGFuZHNoYWtlUmVzcG9uc2UoATABElMKC0xpc3RGbGlnaHRzEh8uYXJyb3cuZmxpZ2h0LnByb3RvY29sLkNyaXRlcmlhGiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodEluZm8wARJbCg1HZXRGbGlnaHRJbmZvEicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERlc2NyaXB0b3IaIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0SW5mbxJaCg5Qb2xsRmxpZ2h0SW5mbxInLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yGh8uYXJyb3cuZmxpZ2h0LnByb3RvY29sLlBvbGxJbmZvElkKCUdldFNjaGVtYRInLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yGiMuYXJyb3cuZmxpZ2h0LnByb3RvY29sLlNjaGVtYVJlc3VsdBJLCgVEb0dldBIdLmFycm93LmZsaWdodC5wcm90b2NvbC5UaWNrZXQaIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGF0YTABElAKBURvUHV0EiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERhdGEaIC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuUHV0UmVzdWx0KAEwARJWCgpEb0V4Y2hhbmdlEiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERhdGEaIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGF0YSgBMAESSgoIRG9BY3Rpb24SHS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuQWN0aW9uGh0uYXJyb3cuZmxpZ2h0LnByb3RvY29sLlJlc3VsdDABElAKC0xpc3RBY3Rpb25zEhwuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkVtcHR5GiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkFjdGlvblR5cGUwAULbAQoZY29tLmFycm93LmZsaWdodC5wcm90b2NvbEILRmxpZ2h0UHJvdG9QAVo7Z2l0aHViLmNvbS9jcmVhbS10cmFkaW5nL2NyZWFtL2dlbi9nby9hcnJvdy9mbGlnaHQvcHJvdG9jb2yiAgNBRlCqAhVBcnJvdy5GbGlnaHQuUHJvdG9jb2zKAhVBcnJvd1xGbGlnaHRcUHJvdG9jb2ziAiFBcnJvd1xGbGlnaHRcUHJvdG9jb2xcR1BCTWV0YWRhdGHqAhdBcnJvdzo6RmxpZ2h0OjpQcm90b2NvbGIGcHJvdG8z");

/**
 * The request that a client provides to a server on handshake.
 *
 * @generated from message arrow.flight.protocol.HandshakeRequest
 */
export type HandshakeRequest = Message<"arrow.flight.protocol.HandshakeRequest"> & {
  /**
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion: bigint;

  /**
   * Arbitrary auth/handshake info
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.HandshakeRequest.
 * Use `create(HandshakeRequestSchema)` to create a new message.
 */
export const HandshakeRequestSchema: GenMessage<HandshakeRequest> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 0);

/**
 * The response a server provides to a client on handshake.
 *
 * @generated from message arrow.flight.protocol.HandshakeResponse
 */
export type HandshakeResponse = Message<"arrow.flight.protocol.HandshakeResponse"> & {
  /**
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion: bigint;

  /**
   * Arbitrary auth/handshake info
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.HandshakeResponse.
 * Use `create(HandshakeResponseSchema)` to create a new message.
 */
export const HandshakeResponseSchema: GenMessage<HandshakeResponse> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 1);

/**
 * A message for doing simple auth
 *
 * @generated from message arrow.flight.protocol.BasicAuth
 */
export type BasicAuth = Message<"arrow.flight.protocol.BasicAuth"> & {
  /**
   * @generated from field: string username = 2;
   */
  username: string;

  /**
   * @generated from field: string password = 3;
   */
  password: string;
};

/**
 * Describes the message arrow.flight.protocol.BasicAuth.
 * Use `create(BasicAuthSchema)` to create a new message.
 */
export const BasicAuthSchema: GenMessage<BasicAuth> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 2);

/**
 * An empty message
 *
 * @generated from message arrow.flight.protocol.Empty
 */
export type Empty = Message<"arrow.flight.protocol.Empty"> & {
};

/**
 * Describes the message arrow.flight.protocol.Empty.
 * Use `create(EmptySchema)` to create a new message.
 */
export const EmptySchema: GenMessage<Empty> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 3);

/**
 * Describes an available action, including both the name used for execution
 * along with a short description of the purpose of the action.
 *
 * @generated from message arrow.flight.protocol.ActionType
 */
export type ActionType = Message<"arrow.flight.protocol.ActionType"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
};

/**
 * Describes the message arrow.flight.protocol.ActionType.
 * Use `create(ActionTypeSchema)` to create a new message.
 */
export const ActionTypeSchema: GenMessage<ActionType> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 4);

/**
 * A service specific expression used to produce a filter.
 *
 * @generated from message arrow.flight.protocol.Criteria
 */
export type Criteria = Message<"arrow.flight.protocol.Criteria"> & {
  /**
   * @generated from field: bytes expression = 1;
   */
  expression: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Criteria.
 * Use `create(CriteriaSchema)` to create a new message.
 */
export const CriteriaSchema: GenMessage<Criteria> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 5);

/**
 * An opaque action specific for the service.
 *
 * @generated from message arrow.flight.protocol.Action
 */
export type Action = Message<"arrow.flight.protocol.Action"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: bytes body = 2;
   */
  body: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Action.
 * Use `create(ActionSchema)` to create a new message.
 */
export const ActionSchema: GenMessage<Action> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 6);

/**
 * An opaque result returned after executing an action.
 *
 * @generated from message arrow.flight.protocol.Result
 */
export type Result = Message<"arrow.flight.protocol.Result"> & {
  /**
   * @generated from field: bytes body = 1;
   */
  body: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Result.
 * Use `create(ResultSchema)` to create a new message.
 */
export const ResultSchema: GenMessage<Result> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 7);

/**
 * Wrap the result of a getSchema call
 *
 * @generated from message arrow.flight.protocol.SchemaResult
 */
export type SchemaResult = Message<"arrow.flight.protocol.SchemaResult"> & {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.SchemaResult.
 * Use `create(SchemaResultSchema)` to create a new message.
 */
export const SchemaResultSchema: GenMessage<SchemaResult> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 8);

/**
 * The name or tag for a Flight. May be used as a way to retrieve or generate
 * a flight or be used to expose a set of previously defined flights.
 *
 * @generated from message arrow.flight.protocol.FlightDescriptor
 */
export type FlightDescriptor = Message<"arrow.flight.protocol.FlightDescriptor"> & {
  /**
   * @generated from field: arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
   */
  type: FlightDescriptor_DescriptorType;

  /**
   * Opaque value used to express a command. Should only be defined when
   * type = CMD.
   *
   * @generated from field: bytes cmd = 2;
   */
  cmd: Uint8Array;

  /**
   * List of strings identifying a particular dataset. Should only be defined
   * when type = PATH.
   *
   * @generated from field: repeated string path = 3;
   */
  path: string[];
};

/**
 * Describes the message arrow.flight.protocol.FlightDescriptor.
 * Use `create(FlightDescriptorSchema)` to create a new message.
 */
export const FlightDescriptorSchema: GenMessage<FlightDescriptor> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 9);

/**
 * Describes what type of descriptor is defined.
 *
 * @generated from enum arrow.flight.protocol.FlightDescriptor.DescriptorType
 */
export enum FlightDescriptor_DescriptorType {
  /**
   * Protobuf pattern, not used.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * A named path that identifies a dataset.
   *
   * @generated from enum value: PATH = 1;
   */
  PATH = 1,

  /**
   * An opaque command to generate a dataset.
   *
   * @generated from enum value: CMD = 2;
   */
  CMD = 2,
}

/**
 * Describes the enum arrow.flight.protocol.FlightDescriptor.DescriptorType.
 */
export const FlightDescriptor_DescriptorTypeSchema: GenEnum<FlightDescriptor_DescriptorType> = /*@__PURE__*/
  enumDesc(file_arrow_flight_protocol_flight, 9, 0);

/**
 * The access coordinates for retrieval of a dataset. With a FlightInfo, a
 * consumer can determine how to retrieve a dataset.
 *
 * @generated from message arrow.flight.protocol.FlightInfo
 */
export type FlightInfo = Message<"arrow.flight.protocol.FlightInfo"> & {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema: Uint8Array;

  /**
   * The descriptor associated with this info.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * A list of endpoints associated with the flight. To consume the
   * whole flight, all endpoints (and hence all Tickets) must be
   * consumed. Endpoints can be consumed in any order.
   *
   * In other words, an application can use multiple endpoints to
   * represent partitioned data.
   *
   * If the returned data has an ordering, an application can use
   * "FlightInfo.ordered = true" or should return the all data in a
   * single endpoint. Otherwise, there is no ordering defined on
   * endpoints or the data within.
   *
   * A client can read ordered data by reading data from returned
   * endpoints, in order, from front to back.
   *
   * Note that a client may ignore "FlightInfo.ordered = true". If an
   * ordering is important for an application, an application must
   * choose one of them:
   *
   * * An application requires that all clients must read data in
   *   returned endpoints order.
   * * An application must return the all data in a single endpoint.
   *
   * @generated from field: repeated arrow.flight.protocol.FlightEndpoint endpoint = 3;
   */
  endpoint: FlightEndpoint[];

  /**
   * Set these to -1 if unknown.
   *
   * @generated from field: int64 total_records = 4;
   */
  totalRecords: bigint;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes: bigint;

  /**
   * FlightEndpoints are in the same order as the data.
   *
   * @generated from field: bool ordered = 6;
   */
  ordered: boolean;

  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightEndpoints or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 7;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightInfo.
 * Use `create(FlightInfoSchema)` to create a new message.
 */
export const FlightInfoSchema: GenMessage<FlightInfo> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 10);

/**
 * The information to process a long-running query.
 *
 * @generated from message arrow.flight.protocol.PollInfo
 */
export type PollInfo = Message<"arrow.flight.protocol.PollInfo"> & {
  /**
   * The currently available results.
   *
   * If "weights" is not empty, this FlightInfo only contains a
   * portion of the results. Otherwise, this FlightInfo contains all
   * results.
   *
   * @generated from field: arrow.flight.protocol.FlightInfo info = 1;
   */
  info?: FlightInfo;

  /**
   * The descriptor the client should use on the next try.
   * If unset, the query is complete and GetFlightInfo currently
   * contains all results. Otherwise, the client should call
   * PollFlightInfo with this descriptor to continue.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * Query progress. If known, must be in [0.0, 1.0] but need not be
   * monotonically increasing.
   *
   * @generated from field: optional double progress = 3;
   */
  progress?: number;

  /**
   * Expiration time for this request. After this passes, the server
   * might not accept the retry descriptor anymore (and the query may
   * be cancelled). This may be updated on a call to PollFlightInfo.
   *
   * @generated from field: optional int64 expiration_time = 4;
   */
  expirationTime?: bigint;
};

/**
 * Describes the message arrow.flight.protocol.PollInfo.
 * Use `create(PollInfoSchema)` to create a new message.
 */
export const PollInfoSchema: GenMessage<PollInfo> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 11);

/**
 * A particular stream or split associated with a flight.
 *
 * @generated from message arrow.flight.protocol.FlightEndpoint
 */
export type FlightEndpoint = Message<"arrow.flight.protocol.FlightEndpoint"> & {
  /**
   * Token used to retrieve this stream.
   *
   * @generated from field: arrow.flight.protocol.Ticket ticket = 1;
   */
  ticket?: Ticket;

  /**
   * A list of URIs where this ticket can be redeemed via DoGet().
   *
   * If the list is empty, the ticket can only be redeemed on the
   * current service where the ticket was generated.
   *
   * If the list is not empty, the ticket can be redeemed at any of the
   * locations, and at least one of the locations should be the same
   * location as was used to generate the ticket.
   *
   * Locations may contain the same host but different ports. They
   * may also be different hosts.
   *
   * @generated from field: repeated arrow.flight.protocol.Location location = 2;
   */
  location: Location[];

  /**
   * Expiration time of this stream. If present, clients may assume
   * they can retry DoGet requests. Otherwise, it is
   * application-defined whether DoGet requests may be retried.
   *
   * @generated from field: optional int64 expiration_time = 3;
   */
  expirationTime?: bigint;

  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightInfo or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 4;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightEndpoint.
 * Use `create(FlightEndpointSchema)` to create a new message.
 */
export const FlightEndpointSchema: GenMessage<FlightEndpoint> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 12);

/**
 * A location where a Flight service will accept retrieval of a particular
 * stream given a ticket.
 *
 * @generated from message arrow.flight.protocol.Location
 */
export type Location = Message<"arrow.flight.protocol.Location"> & {
  /**
   * @generated from field: string uri = 1;
   */
  uri: string;
};

/**
 * Describes the message arrow.flight.protocol.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 13);

/**
 * An opaque identifier that the service can use to retrieve a particular
 * portion of a stream.
 *
 * Tickets are meant to be single use. It is an error/application-defined
 * behavior to reuse a ticket.
 *
 * @generated from message arrow.flight.protocol.Ticket
 */
export type Ticket = Message<"arrow.flight.protocol.Ticket"> & {
  /**
   * @generated from field: bytes ticket = 1;
   */
  ticket: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Ticket.
 * Use `create(TicketSchema)` to create a new message.
 */
export const TicketSchema: GenMessage<Ticket> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 14);

/**
 * A batch of Arrow data as part of a stream of batches.
 *
 * @generated from message arrow.flight.protocol.FlightData
 */
export type FlightData = Message<"arrow.flight.protocol.FlightData"> & {
  /**
   * The descriptor of the data. This is only relevant when a client is
   * starting a new DoPut stream.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * Header for message data as described in Message.fbs::Message.
   *
   * @generated from field: bytes data_header = 2;
   */
  dataHeader: Uint8Array;

  /**
   * Application-defined metadata.
   *
   * @generated from field: bytes app_metadata = 3;
   */
  appMetadata: Uint8Array;

  /**
   * The actual batch of Arrow data. Preferably handled with minimal-copies
   * coming last in the definition to help with sidecar patterns (it is
   * expected that some implementations will fetch this field off the wire
   * with specialized code to avoid extra memory copies).
   *
   * @generated from field: bytes data_body = 1000;
   */
  dataBody: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightData.
 * Use `create(FlightDataSchema)` to create a new message.
 */
export const FlightDataSchema: GenMessage<FlightData> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 15);

/**
 * The response message associated with the submission of a DoPut.
 *
 * @generated from message arrow.flight.protocol.PutResult
 */
export type PutResult = Message<"arrow.flight.protocol.PutResult"> & {
  /**
   * @generated from field: bytes app_metadata = 1;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.PutResult.
 * Use `create(PutResultSchema)` to create a new message.
 */
export const PutResultSchema: GenMessage<PutResult> = /*@__PURE__*/
  messageDesc(file_arrow_flight_protocol_flight, 16);

/**
 * A flight service is an endpoint for retrieving or storing Arrow data.
 *
 * @generated from service arrow.flight.protocol.FlightService
 */
export const FlightService: GenService<{
  /**
   * Handshake between client and server. Depending on the server, the
   * handshake may be required to determine the token that should be used for
   * future operations.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.Handshake
   */
  handshake: {
    methodKind: "bidi_streaming";
    input: typeof HandshakeRequestSchema;
    output: typeof HandshakeResponseSchema;
  },
  /**
   * Get a list of available streams given a particular criteria.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.ListFlights
   */
  listFlights: {
    methodKind: "server_streaming";
    input: typeof CriteriaSchema;
    output: typeof FlightInfoSchema;
  },
  /**
   * For a given FlightDescriptor, get information about how the flight can be
   * consumed.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.GetFlightInfo
   */
  getFlightInfo: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof FlightInfoSchema;
  },
  /**
   * For a given FlightDescriptor, start a query and get information
   * to poll its execution status.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.PollFlightInfo
   */
  pollFlightInfo: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof PollInfoSchema;
  },
  /**
   * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.GetSchema
   */
  getSchema: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof SchemaResultSchema;
  },
  /**
   * Retrieve a single stream associated with a particular descriptor
   * associated with the referenced ticket.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoGet
   */
  doGet: {
    methodKind: "server_streaming";
    input: typeof TicketSchema;
    output: typeof FlightDataSchema;
  },
  /**
   * Push a stream to the flight service associated with a particular
   * flight stream.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoPut
   */
  doPut: {
    methodKind: "bidi_streaming";
    input: typeof FlightDataSchema;
    output: typeof PutResultSchema;
  },
  /**
   * Open a bidirectional data channel for a given descriptor.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoExchange
   */
  doExchange: {
    methodKind: "bidi_streaming";
    input: typeof FlightDataSchema;
    output: typeof FlightDataSchema;
  },
  /**
   * Flight services can support an arbitrary number of simple actions in
   * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
   * operations that are potentially available.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoAction
   */
  doAction: {
    methodKind: "server_streaming";
    input: typeof ActionSchema;
    output: typeof ResultSchema;
  },
  /**
   * A flight service exposes all of the available action types that it has
   * along with descriptions.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.ListActions
   */
  listActions: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof ActionTypeSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_arrow_flight_protocol_flight, 0);

