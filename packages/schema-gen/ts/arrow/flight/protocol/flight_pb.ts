// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// Arrow Flight protocol definition (simplified for TypeScript client)

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file arrow/flight/protocol/flight.proto (package arrow.flight.protocol, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * The request that a client provides to a server on handshake.
 *
 * @generated from message arrow.flight.protocol.HandshakeRequest
 */
export class HandshakeRequest extends Message<HandshakeRequest> {
  /**
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion = protoInt64.zero;

  /**
   * Arbitrary auth/handshake info
   *
   * @generated from field: bytes payload = 2;
   */
  payload = new Uint8Array(0);

  constructor(data?: PartialMessage<HandshakeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.HandshakeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "protocol_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HandshakeRequest {
    return new HandshakeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HandshakeRequest {
    return new HandshakeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HandshakeRequest {
    return new HandshakeRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: HandshakeRequest | PlainMessage<HandshakeRequest> | undefined,
    b: HandshakeRequest | PlainMessage<HandshakeRequest> | undefined
  ): boolean {
    return proto3.util.equals(HandshakeRequest, a, b);
  }
}

/**
 * The response a server provides to a client on handshake.
 *
 * @generated from message arrow.flight.protocol.HandshakeResponse
 */
export class HandshakeResponse extends Message<HandshakeResponse> {
  /**
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion = protoInt64.zero;

  /**
   * Arbitrary auth/handshake info
   *
   * @generated from field: bytes payload = 2;
   */
  payload = new Uint8Array(0);

  constructor(data?: PartialMessage<HandshakeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.HandshakeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "protocol_version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "payload", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HandshakeResponse {
    return new HandshakeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HandshakeResponse {
    return new HandshakeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HandshakeResponse {
    return new HandshakeResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: HandshakeResponse | PlainMessage<HandshakeResponse> | undefined,
    b: HandshakeResponse | PlainMessage<HandshakeResponse> | undefined
  ): boolean {
    return proto3.util.equals(HandshakeResponse, a, b);
  }
}

/**
 * A message for doing simple auth
 *
 * @generated from message arrow.flight.protocol.BasicAuth
 */
export class BasicAuth extends Message<BasicAuth> {
  /**
   * @generated from field: string username = 2;
   */
  username = "";

  /**
   * @generated from field: string password = 3;
   */
  password = "";

  constructor(data?: PartialMessage<BasicAuth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.BasicAuth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BasicAuth {
    return new BasicAuth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BasicAuth {
    return new BasicAuth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BasicAuth {
    return new BasicAuth().fromJsonString(jsonString, options);
  }

  static equals(
    a: BasicAuth | PlainMessage<BasicAuth> | undefined,
    b: BasicAuth | PlainMessage<BasicAuth> | undefined
  ): boolean {
    return proto3.util.equals(BasicAuth, a, b);
  }
}

/**
 * An empty message
 *
 * @generated from message arrow.flight.protocol.Empty
 */
export class Empty extends Message<Empty> {
  constructor(data?: PartialMessage<Empty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Empty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Empty {
    return new Empty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Empty {
    return new Empty().fromJsonString(jsonString, options);
  }

  static equals(
    a: Empty | PlainMessage<Empty> | undefined,
    b: Empty | PlainMessage<Empty> | undefined
  ): boolean {
    return proto3.util.equals(Empty, a, b);
  }
}

/**
 * Describes an available action, including both the name used for execution
 * along with a short description of the purpose of the action.
 *
 * @generated from message arrow.flight.protocol.ActionType
 */
export class ActionType extends Message<ActionType> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: string description = 2;
   */
  description = "";

  constructor(data?: PartialMessage<ActionType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.ActionType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionType {
    return new ActionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionType {
    return new ActionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionType {
    return new ActionType().fromJsonString(jsonString, options);
  }

  static equals(
    a: ActionType | PlainMessage<ActionType> | undefined,
    b: ActionType | PlainMessage<ActionType> | undefined
  ): boolean {
    return proto3.util.equals(ActionType, a, b);
  }
}

/**
 * A service specific expression used to produce a filter.
 *
 * @generated from message arrow.flight.protocol.Criteria
 */
export class Criteria extends Message<Criteria> {
  /**
   * @generated from field: bytes expression = 1;
   */
  expression = new Uint8Array(0);

  constructor(data?: PartialMessage<Criteria>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Criteria";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expression", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Criteria {
    return new Criteria().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Criteria {
    return new Criteria().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Criteria {
    return new Criteria().fromJsonString(jsonString, options);
  }

  static equals(
    a: Criteria | PlainMessage<Criteria> | undefined,
    b: Criteria | PlainMessage<Criteria> | undefined
  ): boolean {
    return proto3.util.equals(Criteria, a, b);
  }
}

/**
 * An opaque action specific for the service.
 *
 * @generated from message arrow.flight.protocol.Action
 */
export class Action extends Message<Action> {
  /**
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * @generated from field: bytes body = 2;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(
    a: Action | PlainMessage<Action> | undefined,
    b: Action | PlainMessage<Action> | undefined
  ): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * An opaque result returned after executing an action.
 *
 * @generated from message arrow.flight.protocol.Result
 */
export class Result extends Message<Result> {
  /**
   * @generated from field: bytes body = 1;
   */
  body = new Uint8Array(0);

  constructor(data?: PartialMessage<Result>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Result";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Result {
    return new Result().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Result {
    return new Result().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Result {
    return new Result().fromJsonString(jsonString, options);
  }

  static equals(
    a: Result | PlainMessage<Result> | undefined,
    b: Result | PlainMessage<Result> | undefined
  ): boolean {
    return proto3.util.equals(Result, a, b);
  }
}

/**
 * Wrap the result of a getSchema call
 *
 * @generated from message arrow.flight.protocol.SchemaResult
 */
export class SchemaResult extends Message<SchemaResult> {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema = new Uint8Array(0);

  constructor(data?: PartialMessage<SchemaResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.SchemaResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaResult {
    return new SchemaResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaResult {
    return new SchemaResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaResult {
    return new SchemaResult().fromJsonString(jsonString, options);
  }

  static equals(
    a: SchemaResult | PlainMessage<SchemaResult> | undefined,
    b: SchemaResult | PlainMessage<SchemaResult> | undefined
  ): boolean {
    return proto3.util.equals(SchemaResult, a, b);
  }
}

/**
 * The name or tag for a Flight. May be used as a way to retrieve or generate
 * a flight or be used to expose a set of previously defined flights.
 *
 * @generated from message arrow.flight.protocol.FlightDescriptor
 */
export class FlightDescriptor extends Message<FlightDescriptor> {
  /**
   * @generated from field: arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
   */
  type = FlightDescriptor_DescriptorType.UNKNOWN;

  /**
   * Opaque value used to express a command. Should only be defined when
   * type = CMD.
   *
   * @generated from field: bytes cmd = 2;
   */
  cmd = new Uint8Array(0);

  /**
   * List of strings identifying a particular dataset. Should only be defined
   * when type = PATH.
   *
   * @generated from field: repeated string path = 3;
   */
  path: string[] = [];

  constructor(data?: PartialMessage<FlightDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.FlightDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(FlightDescriptor_DescriptorType) },
    { no: 2, name: "cmd", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlightDescriptor {
    return new FlightDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlightDescriptor {
    return new FlightDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlightDescriptor {
    return new FlightDescriptor().fromJsonString(jsonString, options);
  }

  static equals(
    a: FlightDescriptor | PlainMessage<FlightDescriptor> | undefined,
    b: FlightDescriptor | PlainMessage<FlightDescriptor> | undefined
  ): boolean {
    return proto3.util.equals(FlightDescriptor, a, b);
  }
}

/**
 * Describes what type of descriptor is defined.
 *
 * @generated from enum arrow.flight.protocol.FlightDescriptor.DescriptorType
 */
export enum FlightDescriptor_DescriptorType {
  /**
   * Protobuf pattern, not used.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * A named path that identifies a dataset.
   *
   * @generated from enum value: PATH = 1;
   */
  PATH = 1,

  /**
   * An opaque command to generate a dataset.
   *
   * @generated from enum value: CMD = 2;
   */
  CMD = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(FlightDescriptor_DescriptorType)
proto3.util.setEnumType(
  FlightDescriptor_DescriptorType,
  "arrow.flight.protocol.FlightDescriptor.DescriptorType",
  [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "PATH" },
    { no: 2, name: "CMD" },
  ]
);

/**
 * The access coordinates for retrieval of a dataset. With a FlightInfo, a
 * consumer can determine how to retrieve a dataset.
 *
 * @generated from message arrow.flight.protocol.FlightInfo
 */
export class FlightInfo extends Message<FlightInfo> {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema = new Uint8Array(0);

  /**
   * The descriptor associated with this info.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * A list of endpoints associated with the flight. To consume the
   * whole flight, all endpoints (and hence all Tickets) must be
   * consumed. Endpoints can be consumed in any order.
   *
   * In other words, an application can use multiple endpoints to
   * represent partitioned data.
   *
   * If the returned data has an ordering, an application can use
   * "FlightInfo.ordered = true" or should return the all data in a
   * single endpoint. Otherwise, there is no ordering defined on
   * endpoints or the data within.
   *
   * A client can read ordered data by reading data from returned
   * endpoints, in order, from front to back.
   *
   * Note that a client may ignore "FlightInfo.ordered = true". If an
   * ordering is important for an application, an application must
   * choose one of them:
   *
   * * An application requires that all clients must read data in
   *   returned endpoints order.
   * * An application must return the all data in a single endpoint.
   *
   * @generated from field: repeated arrow.flight.protocol.FlightEndpoint endpoint = 3;
   */
  endpoint: FlightEndpoint[] = [];

  /**
   * Set these to -1 if unknown.
   *
   * @generated from field: int64 total_records = 4;
   */
  totalRecords = protoInt64.zero;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes = protoInt64.zero;

  /**
   * FlightEndpoints are in the same order as the data.
   *
   * @generated from field: bool ordered = 6;
   */
  ordered = false;

  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightEndpoints or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 7;
   */
  appMetadata = new Uint8Array(0);

  constructor(data?: PartialMessage<FlightInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.FlightInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "flight_descriptor", kind: "message", T: FlightDescriptor },
    { no: 3, name: "endpoint", kind: "message", T: FlightEndpoint, repeated: true },
    { no: 4, name: "total_records", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "total_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "ordered", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "app_metadata", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlightInfo {
    return new FlightInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlightInfo {
    return new FlightInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlightInfo {
    return new FlightInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: FlightInfo | PlainMessage<FlightInfo> | undefined,
    b: FlightInfo | PlainMessage<FlightInfo> | undefined
  ): boolean {
    return proto3.util.equals(FlightInfo, a, b);
  }
}

/**
 * The information to process a long-running query.
 *
 * @generated from message arrow.flight.protocol.PollInfo
 */
export class PollInfo extends Message<PollInfo> {
  /**
   * The currently available results.
   *
   * If "weights" is not empty, this FlightInfo only contains a
   * portion of the results. Otherwise, this FlightInfo contains all
   * results.
   *
   * @generated from field: arrow.flight.protocol.FlightInfo info = 1;
   */
  info?: FlightInfo;

  /**
   * The descriptor the client should use on the next try.
   * If unset, the query is complete and GetFlightInfo currently
   * contains all results. Otherwise, the client should call
   * PollFlightInfo with this descriptor to continue.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * Query progress. If known, must be in [0.0, 1.0] but need not be
   * monotonically increasing.
   *
   * @generated from field: optional double progress = 3;
   */
  progress?: number;

  /**
   * Expiration time for this request. After this passes, the server
   * might not accept the retry descriptor anymore (and the query may
   * be cancelled). This may be updated on a call to PollFlightInfo.
   *
   * @generated from field: optional int64 expiration_time = 4;
   */
  expirationTime?: bigint;

  constructor(data?: PartialMessage<PollInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.PollInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info", kind: "message", T: FlightInfo },
    { no: 2, name: "flight_descriptor", kind: "message", T: FlightDescriptor },
    { no: 3, name: "progress", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "expiration_time", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PollInfo {
    return new PollInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PollInfo {
    return new PollInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PollInfo {
    return new PollInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: PollInfo | PlainMessage<PollInfo> | undefined,
    b: PollInfo | PlainMessage<PollInfo> | undefined
  ): boolean {
    return proto3.util.equals(PollInfo, a, b);
  }
}

/**
 * A particular stream or split associated with a flight.
 *
 * @generated from message arrow.flight.protocol.FlightEndpoint
 */
export class FlightEndpoint extends Message<FlightEndpoint> {
  /**
   * Token used to retrieve this stream.
   *
   * @generated from field: arrow.flight.protocol.Ticket ticket = 1;
   */
  ticket?: Ticket;

  /**
   * A list of URIs where this ticket can be redeemed via DoGet().
   *
   * If the list is empty, the ticket can only be redeemed on the
   * current service where the ticket was generated.
   *
   * If the list is not empty, the ticket can be redeemed at any of the
   * locations, and at least one of the locations should be the same
   * location as was used to generate the ticket.
   *
   * Locations may contain the same host but different ports. They
   * may also be different hosts.
   *
   * @generated from field: repeated arrow.flight.protocol.Location location = 2;
   */
  location: Location[] = [];

  /**
   * Expiration time of this stream. If present, clients may assume
   * they can retry DoGet requests. Otherwise, it is
   * application-defined whether DoGet requests may be retried.
   *
   * @generated from field: optional int64 expiration_time = 3;
   */
  expirationTime?: bigint;

  /**
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightInfo or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 4;
   */
  appMetadata = new Uint8Array(0);

  constructor(data?: PartialMessage<FlightEndpoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.FlightEndpoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticket", kind: "message", T: Ticket },
    { no: 2, name: "location", kind: "message", T: Location, repeated: true },
    { no: 3, name: "expiration_time", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 4, name: "app_metadata", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlightEndpoint {
    return new FlightEndpoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlightEndpoint {
    return new FlightEndpoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlightEndpoint {
    return new FlightEndpoint().fromJsonString(jsonString, options);
  }

  static equals(
    a: FlightEndpoint | PlainMessage<FlightEndpoint> | undefined,
    b: FlightEndpoint | PlainMessage<FlightEndpoint> | undefined
  ): boolean {
    return proto3.util.equals(FlightEndpoint, a, b);
  }
}

/**
 * A location where a Flight service will accept retrieval of a particular
 * stream given a ticket.
 *
 * @generated from message arrow.flight.protocol.Location
 */
export class Location extends Message<Location> {
  /**
   * @generated from field: string uri = 1;
   */
  uri = "";

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(
    a: Location | PlainMessage<Location> | undefined,
    b: Location | PlainMessage<Location> | undefined
  ): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

/**
 * An opaque identifier that the service can use to retrieve a particular
 * portion of a stream.
 *
 * Tickets are meant to be single use. It is an error/application-defined
 * behavior to reuse a ticket.
 *
 * @generated from message arrow.flight.protocol.Ticket
 */
export class Ticket extends Message<Ticket> {
  /**
   * @generated from field: bytes ticket = 1;
   */
  ticket = new Uint8Array(0);

  constructor(data?: PartialMessage<Ticket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.Ticket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticket", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Ticket {
    return new Ticket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Ticket {
    return new Ticket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Ticket {
    return new Ticket().fromJsonString(jsonString, options);
  }

  static equals(
    a: Ticket | PlainMessage<Ticket> | undefined,
    b: Ticket | PlainMessage<Ticket> | undefined
  ): boolean {
    return proto3.util.equals(Ticket, a, b);
  }
}

/**
 * A batch of Arrow data as part of a stream of batches.
 *
 * @generated from message arrow.flight.protocol.FlightData
 */
export class FlightData extends Message<FlightData> {
  /**
   * The descriptor of the data. This is only relevant when a client is
   * starting a new DoPut stream.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   * Header for message data as described in Message.fbs::Message.
   *
   * @generated from field: bytes data_header = 2;
   */
  dataHeader = new Uint8Array(0);

  /**
   * Application-defined metadata.
   *
   * @generated from field: bytes app_metadata = 3;
   */
  appMetadata = new Uint8Array(0);

  /**
   * The actual batch of Arrow data. Preferably handled with minimal-copies
   * coming last in the definition to help with sidecar patterns (it is
   * expected that some implementations will fetch this field off the wire
   * with specialized code to avoid extra memory copies).
   *
   * @generated from field: bytes data_body = 1000;
   */
  dataBody = new Uint8Array(0);

  constructor(data?: PartialMessage<FlightData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.FlightData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "flight_descriptor", kind: "message", T: FlightDescriptor },
    { no: 2, name: "data_header", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "app_metadata", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 1000, name: "data_body", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlightData {
    return new FlightData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlightData {
    return new FlightData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlightData {
    return new FlightData().fromJsonString(jsonString, options);
  }

  static equals(
    a: FlightData | PlainMessage<FlightData> | undefined,
    b: FlightData | PlainMessage<FlightData> | undefined
  ): boolean {
    return proto3.util.equals(FlightData, a, b);
  }
}

/**
 * The response message associated with the submission of a DoPut.
 *
 * @generated from message arrow.flight.protocol.PutResult
 */
export class PutResult extends Message<PutResult> {
  /**
   * @generated from field: bytes app_metadata = 1;
   */
  appMetadata = new Uint8Array(0);

  constructor(data?: PartialMessage<PutResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "arrow.flight.protocol.PutResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "app_metadata", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutResult {
    return new PutResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutResult {
    return new PutResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutResult {
    return new PutResult().fromJsonString(jsonString, options);
  }

  static equals(
    a: PutResult | PlainMessage<PutResult> | undefined,
    b: PutResult | PlainMessage<PutResult> | undefined
  ): boolean {
    return proto3.util.equals(PutResult, a, b);
  }
}
