// Cream Trading System - Common Types
// Shared enums and messages used across the system
//
// NOTE: Using proto3 until Prost (Rust) supports Protobuf Editions.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file cream/v1/common.proto (package cream.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Trading environment
 *
 * @generated from enum cream.v1.Environment
 */
export enum Environment {
  /**
   * @generated from enum value: ENVIRONMENT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ENVIRONMENT_BACKTEST = 1;
   */
  BACKTEST = 1,

  /**
   * @generated from enum value: ENVIRONMENT_PAPER = 2;
   */
  PAPER = 2,

  /**
   * @generated from enum value: ENVIRONMENT_LIVE = 3;
   */
  LIVE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Environment)
proto3.util.setEnumType(Environment, "cream.v1.Environment", [
  { no: 0, name: "ENVIRONMENT_UNSPECIFIED" },
  { no: 1, name: "ENVIRONMENT_BACKTEST" },
  { no: 2, name: "ENVIRONMENT_PAPER" },
  { no: 3, name: "ENVIRONMENT_LIVE" },
]);

/**
 * Trading action that expresses intent in terms of exposure
 *
 * @generated from enum cream.v1.Action
 */
export enum Action {
  /**
   * @generated from enum value: ACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Establish new long from flat
   *
   * @generated from enum value: ACTION_BUY = 1;
   */
  BUY = 1,

  /**
   * Establish new short from flat
   *
   * @generated from enum value: ACTION_SELL = 2;
   */
  SELL = 2,

  /**
   * Maintain current position
   *
   * @generated from enum value: ACTION_HOLD = 3;
   */
  HOLD = 3,

  /**
   * Increase exposure in direction
   *
   * @generated from enum value: ACTION_INCREASE = 4;
   */
  INCREASE = 4,

  /**
   * Reduce exposure magnitude
   *
   * @generated from enum value: ACTION_REDUCE = 5;
   */
  REDUCE = 5,

  /**
   * Remain flat
   *
   * @generated from enum value: ACTION_NO_TRADE = 6;
   */
  NO_TRADE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(Action)
proto3.util.setEnumType(Action, "cream.v1.Action", [
  { no: 0, name: "ACTION_UNSPECIFIED" },
  { no: 1, name: "ACTION_BUY" },
  { no: 2, name: "ACTION_SELL" },
  { no: 3, name: "ACTION_HOLD" },
  { no: 4, name: "ACTION_INCREASE" },
  { no: 5, name: "ACTION_REDUCE" },
  { no: 6, name: "ACTION_NO_TRADE" },
]);

/**
 * Direction derived from action and position
 *
 * @generated from enum cream.v1.Direction
 */
export enum Direction {
  /**
   * @generated from enum value: DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: DIRECTION_LONG = 1;
   */
  LONG = 1,

  /**
   * @generated from enum value: DIRECTION_SHORT = 2;
   */
  SHORT = 2,

  /**
   * @generated from enum value: DIRECTION_FLAT = 3;
   */
  FLAT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Direction)
proto3.util.setEnumType(Direction, "cream.v1.Direction", [
  { no: 0, name: "DIRECTION_UNSPECIFIED" },
  { no: 1, name: "DIRECTION_LONG" },
  { no: 2, name: "DIRECTION_SHORT" },
  { no: 3, name: "DIRECTION_FLAT" },
]);

/**
 * Instrument type
 *
 * @generated from enum cream.v1.InstrumentType
 */
export enum InstrumentType {
  /**
   * @generated from enum value: INSTRUMENT_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: INSTRUMENT_TYPE_EQUITY = 1;
   */
  EQUITY = 1,

  /**
   * @generated from enum value: INSTRUMENT_TYPE_OPTION = 2;
   */
  OPTION = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(InstrumentType)
proto3.util.setEnumType(InstrumentType, "cream.v1.InstrumentType", [
  { no: 0, name: "INSTRUMENT_TYPE_UNSPECIFIED" },
  { no: 1, name: "INSTRUMENT_TYPE_EQUITY" },
  { no: 2, name: "INSTRUMENT_TYPE_OPTION" },
]);

/**
 * Option type (call or put)
 *
 * @generated from enum cream.v1.OptionType
 */
export enum OptionType {
  /**
   * @generated from enum value: OPTION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPTION_TYPE_CALL = 1;
   */
  CALL = 1,

  /**
   * @generated from enum value: OPTION_TYPE_PUT = 2;
   */
  PUT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OptionType)
proto3.util.setEnumType(OptionType, "cream.v1.OptionType", [
  { no: 0, name: "OPTION_TYPE_UNSPECIFIED" },
  { no: 1, name: "OPTION_TYPE_CALL" },
  { no: 2, name: "OPTION_TYPE_PUT" },
]);

/**
 * Size unit for position sizing
 *
 * @generated from enum cream.v1.SizeUnit
 */
export enum SizeUnit {
  /**
   * @generated from enum value: SIZE_UNIT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SIZE_UNIT_SHARES = 1;
   */
  SHARES = 1,

  /**
   * @generated from enum value: SIZE_UNIT_CONTRACTS = 2;
   */
  CONTRACTS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SizeUnit)
proto3.util.setEnumType(SizeUnit, "cream.v1.SizeUnit", [
  { no: 0, name: "SIZE_UNIT_UNSPECIFIED" },
  { no: 1, name: "SIZE_UNIT_SHARES" },
  { no: 2, name: "SIZE_UNIT_CONTRACTS" },
]);

/**
 * Order type
 *
 * @generated from enum cream.v1.OrderType
 */
export enum OrderType {
  /**
   * @generated from enum value: ORDER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ORDER_TYPE_LIMIT = 1;
   */
  LIMIT = 1,

  /**
   * @generated from enum value: ORDER_TYPE_MARKET = 2;
   */
  MARKET = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderType)
proto3.util.setEnumType(OrderType, "cream.v1.OrderType", [
  { no: 0, name: "ORDER_TYPE_UNSPECIFIED" },
  { no: 1, name: "ORDER_TYPE_LIMIT" },
  { no: 2, name: "ORDER_TYPE_MARKET" },
]);

/**
 * Time in force for orders
 *
 * @generated from enum cream.v1.TimeInForce
 */
export enum TimeInForce {
  /**
   * @generated from enum value: TIME_IN_FORCE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: TIME_IN_FORCE_DAY = 1;
   */
  DAY = 1,

  /**
   * Good 'til canceled
   *
   * @generated from enum value: TIME_IN_FORCE_GTC = 2;
   */
  GTC = 2,

  /**
   * Immediate or cancel
   *
   * @generated from enum value: TIME_IN_FORCE_IOC = 3;
   */
  IOC = 3,

  /**
   * Fill or kill
   *
   * @generated from enum value: TIME_IN_FORCE_FOK = 4;
   */
  FOK = 4,

  /**
   * Market-on-open
   *
   * @generated from enum value: TIME_IN_FORCE_OPG = 5;
   */
  OPG = 5,

  /**
   * Market-on-close
   *
   * @generated from enum value: TIME_IN_FORCE_CLS = 6;
   */
  CLS = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(TimeInForce)
proto3.util.setEnumType(TimeInForce, "cream.v1.TimeInForce", [
  { no: 0, name: "TIME_IN_FORCE_UNSPECIFIED" },
  { no: 1, name: "TIME_IN_FORCE_DAY" },
  { no: 2, name: "TIME_IN_FORCE_GTC" },
  { no: 3, name: "TIME_IN_FORCE_IOC" },
  { no: 4, name: "TIME_IN_FORCE_FOK" },
  { no: 5, name: "TIME_IN_FORCE_OPG" },
  { no: 6, name: "TIME_IN_FORCE_CLS" },
]);

/**
 * Risk level denomination
 *
 * @generated from enum cream.v1.RiskDenomination
 */
export enum RiskDenomination {
  /**
   * @generated from enum value: RISK_DENOMINATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: RISK_DENOMINATION_UNDERLYING_PRICE = 1;
   */
  UNDERLYING_PRICE = 1,

  /**
   * @generated from enum value: RISK_DENOMINATION_OPTION_PRICE = 2;
   */
  OPTION_PRICE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(RiskDenomination)
proto3.util.setEnumType(RiskDenomination, "cream.v1.RiskDenomination", [
  { no: 0, name: "RISK_DENOMINATION_UNSPECIFIED" },
  { no: 1, name: "RISK_DENOMINATION_UNDERLYING_PRICE" },
  { no: 2, name: "RISK_DENOMINATION_OPTION_PRICE" },
]);

/**
 * Strategy family
 *
 * @generated from enum cream.v1.StrategyFamily
 */
export enum StrategyFamily {
  /**
   * @generated from enum value: STRATEGY_FAMILY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STRATEGY_FAMILY_TREND = 1;
   */
  TREND = 1,

  /**
   * @generated from enum value: STRATEGY_FAMILY_MEAN_REVERSION = 2;
   */
  MEAN_REVERSION = 2,

  /**
   * @generated from enum value: STRATEGY_FAMILY_EVENT_DRIVEN = 3;
   */
  EVENT_DRIVEN = 3,

  /**
   * @generated from enum value: STRATEGY_FAMILY_VOLATILITY = 4;
   */
  VOLATILITY = 4,

  /**
   * @generated from enum value: STRATEGY_FAMILY_RELATIVE_VALUE = 5;
   */
  RELATIVE_VALUE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(StrategyFamily)
proto3.util.setEnumType(StrategyFamily, "cream.v1.StrategyFamily", [
  { no: 0, name: "STRATEGY_FAMILY_UNSPECIFIED" },
  { no: 1, name: "STRATEGY_FAMILY_TREND" },
  { no: 2, name: "STRATEGY_FAMILY_MEAN_REVERSION" },
  { no: 3, name: "STRATEGY_FAMILY_EVENT_DRIVEN" },
  { no: 4, name: "STRATEGY_FAMILY_VOLATILITY" },
  { no: 5, name: "STRATEGY_FAMILY_RELATIVE_VALUE" },
]);

/**
 * Regime classification
 *
 * @generated from enum cream.v1.Regime
 */
export enum Regime {
  /**
   * @generated from enum value: REGIME_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: REGIME_BULL_TREND = 1;
   */
  BULL_TREND = 1,

  /**
   * @generated from enum value: REGIME_BEAR_TREND = 2;
   */
  BEAR_TREND = 2,

  /**
   * @generated from enum value: REGIME_RANGE_BOUND = 3;
   */
  RANGE_BOUND = 3,

  /**
   * @generated from enum value: REGIME_HIGH_VOLATILITY = 4;
   */
  HIGH_VOLATILITY = 4,

  /**
   * @generated from enum value: REGIME_LOW_VOLATILITY = 5;
   */
  LOW_VOLATILITY = 5,

  /**
   * @generated from enum value: REGIME_CRISIS = 6;
   */
  CRISIS = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(Regime)
proto3.util.setEnumType(Regime, "cream.v1.Regime", [
  { no: 0, name: "REGIME_UNSPECIFIED" },
  { no: 1, name: "REGIME_BULL_TREND" },
  { no: 2, name: "REGIME_BEAR_TREND" },
  { no: 3, name: "REGIME_RANGE_BOUND" },
  { no: 4, name: "REGIME_HIGH_VOLATILITY" },
  { no: 5, name: "REGIME_LOW_VOLATILITY" },
  { no: 6, name: "REGIME_CRISIS" },
]);

/**
 * Market hours status
 *
 * @generated from enum cream.v1.MarketStatus
 */
export enum MarketStatus {
  /**
   * @generated from enum value: MARKET_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: MARKET_STATUS_PRE_MARKET = 1;
   */
  PRE_MARKET = 1,

  /**
   * @generated from enum value: MARKET_STATUS_OPEN = 2;
   */
  OPEN = 2,

  /**
   * @generated from enum value: MARKET_STATUS_AFTER_HOURS = 3;
   */
  AFTER_HOURS = 3,

  /**
   * @generated from enum value: MARKET_STATUS_CLOSED = 4;
   */
  CLOSED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MarketStatus)
proto3.util.setEnumType(MarketStatus, "cream.v1.MarketStatus", [
  { no: 0, name: "MARKET_STATUS_UNSPECIFIED" },
  { no: 1, name: "MARKET_STATUS_PRE_MARKET" },
  { no: 2, name: "MARKET_STATUS_OPEN" },
  { no: 3, name: "MARKET_STATUS_AFTER_HOURS" },
  { no: 4, name: "MARKET_STATUS_CLOSED" },
]);

/**
 * Option contract details
 *
 * @generated from message cream.v1.OptionContract
 */
export class OptionContract extends Message<OptionContract> {
  /**
   * Underlying symbol (e.g., "AAPL")
   *
   * @generated from field: string underlying = 1;
   */
  underlying = "";

  /**
   * Expiration date in YYYY-MM-DD format
   *
   * @generated from field: string expiration = 2;
   */
  expiration = "";

  /**
   * Strike price
   *
   * @generated from field: double strike = 3;
   */
  strike = 0;

  /**
   * Call or put
   *
   * @generated from field: cream.v1.OptionType option_type = 4;
   */
  optionType = OptionType.UNSPECIFIED;

  constructor(data?: PartialMessage<OptionContract>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OptionContract";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "underlying", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expiration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "strike", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "option_type", kind: "enum", T: proto3.getEnumType(OptionType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionContract {
    return new OptionContract().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionContract {
    return new OptionContract().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionContract {
    return new OptionContract().fromJsonString(jsonString, options);
  }

  static equals(
    a: OptionContract | PlainMessage<OptionContract> | undefined,
    b: OptionContract | PlainMessage<OptionContract> | undefined
  ): boolean {
    return proto3.util.equals(OptionContract, a, b);
  }
}

/**
 * Instrument identifier
 *
 * @generated from message cream.v1.Instrument
 */
export class Instrument extends Message<Instrument> {
  /**
   * Unique identifier (ticker or OCC symbol for options)
   *
   * @generated from field: string instrument_id = 1;
   */
  instrumentId = "";

  /**
   * Type of instrument
   *
   * @generated from field: cream.v1.InstrumentType instrument_type = 2;
   */
  instrumentType = InstrumentType.UNSPECIFIED;

  /**
   * Option contract details (required when instrument_type is OPTION)
   *
   * @generated from field: cream.v1.OptionContract option_contract = 3;
   */
  optionContract?: OptionContract;

  constructor(data?: PartialMessage<Instrument>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Instrument";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instrument_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "instrument_type", kind: "enum", T: proto3.getEnumType(InstrumentType) },
    { no: 3, name: "option_contract", kind: "message", T: OptionContract },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Instrument {
    return new Instrument().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Instrument {
    return new Instrument().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Instrument {
    return new Instrument().fromJsonString(jsonString, options);
  }

  static equals(
    a: Instrument | PlainMessage<Instrument> | undefined,
    b: Instrument | PlainMessage<Instrument> | undefined
  ): boolean {
    return proto3.util.equals(Instrument, a, b);
  }
}

/**
 * Position sizing
 *
 * @generated from message cream.v1.Size
 */
export class Size extends Message<Size> {
  /**
   * Number of shares or contracts
   *
   * @generated from field: int32 quantity = 1;
   */
  quantity = 0;

  /**
   * Unit of size
   *
   * @generated from field: cream.v1.SizeUnit unit = 2;
   */
  unit = SizeUnit.UNSPECIFIED;

  /**
   * Target position after execution (signed: positive=long, negative=short)
   *
   * @generated from field: int32 target_position_quantity = 3;
   */
  targetPositionQuantity = 0;

  constructor(data?: PartialMessage<Size>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Size";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "unit", kind: "enum", T: proto3.getEnumType(SizeUnit) },
    { no: 3, name: "target_position_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Size {
    return new Size().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Size {
    return new Size().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Size {
    return new Size().fromJsonString(jsonString, options);
  }

  static equals(
    a: Size | PlainMessage<Size> | undefined,
    b: Size | PlainMessage<Size> | undefined
  ): boolean {
    return proto3.util.equals(Size, a, b);
  }
}

/**
 * Risk levels - mandatory for all decisions
 *
 * @generated from message cream.v1.RiskLevels
 */
export class RiskLevels extends Message<RiskLevels> {
  /**
   * Stop-loss price level
   *
   * @generated from field: double stop_loss_level = 1;
   */
  stopLossLevel = 0;

  /**
   * Take-profit price level
   *
   * @generated from field: double take_profit_level = 2;
   */
  takeProfitLevel = 0;

  /**
   * What price the levels refer to
   *
   * @generated from field: cream.v1.RiskDenomination denomination = 3;
   */
  denomination = RiskDenomination.UNSPECIFIED;

  constructor(data?: PartialMessage<RiskLevels>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.RiskLevels";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stop_loss_level", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "take_profit_level", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "denomination", kind: "enum", T: proto3.getEnumType(RiskDenomination) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskLevels {
    return new RiskLevels().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskLevels {
    return new RiskLevels().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskLevels {
    return new RiskLevels().fromJsonString(jsonString, options);
  }

  static equals(
    a: RiskLevels | PlainMessage<RiskLevels> | undefined,
    b: RiskLevels | PlainMessage<RiskLevels> | undefined
  ): boolean {
    return proto3.util.equals(RiskLevels, a, b);
  }
}
