// Cream Trading System - Decision Schema
// DecisionPlan and related messages for trading decisions
//
// NOTE: Using proto3 until Prost (Rust) supports Protobuf Editions.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file cream/v1/decision.proto (package cream.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, Struct, Timestamp } from "@bufbuild/protobuf";
import {
  Action,
  Environment,
  Instrument,
  OrderType,
  RiskLevels,
  Size,
  StrategyFamily,
  TimeInForce,
} from "./common_pb.js";

/**
 * Order execution plan
 *
 * @generated from message cream.v1.OrderPlan
 */
export class OrderPlan extends Message<OrderPlan> {
  /**
   * Order type for entry
   *
   * @generated from field: cream.v1.OrderType entry_order_type = 1;
   */
  entryOrderType = OrderType.UNSPECIFIED;

  /**
   * Limit price for entry (required when entry_order_type is LIMIT)
   *
   * @generated from field: optional double entry_limit_price = 2;
   */
  entryLimitPrice?: number;

  /**
   * Order type for exit
   *
   * @generated from field: cream.v1.OrderType exit_order_type = 3;
   */
  exitOrderType = OrderType.UNSPECIFIED;

  /**
   * Time in force for orders
   *
   * @generated from field: cream.v1.TimeInForce time_in_force = 4;
   */
  timeInForce = TimeInForce.UNSPECIFIED;

  /**
   * Execution tactic identifier (e.g., "TWAP", "VWAP", "ICEBERG")
   *
   * @generated from field: optional string execution_tactic = 5;
   */
  executionTactic?: string;

  /**
   * Additional execution parameters
   *
   * @generated from field: google.protobuf.Struct execution_params = 6;
   */
  executionParams?: Struct;

  constructor(data?: PartialMessage<OrderPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OrderPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entry_order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 2, name: "entry_limit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "exit_order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "time_in_force", kind: "enum", T: proto3.getEnumType(TimeInForce) },
    { no: 5, name: "execution_tactic", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "execution_params", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderPlan {
    return new OrderPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderPlan {
    return new OrderPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderPlan {
    return new OrderPlan().fromJsonString(jsonString, options);
  }

  static equals(
    a: OrderPlan | PlainMessage<OrderPlan> | undefined,
    b: OrderPlan | PlainMessage<OrderPlan> | undefined
  ): boolean {
    return proto3.util.equals(OrderPlan, a, b);
  }
}

/**
 * References to supporting data
 *
 * @generated from message cream.v1.References
 */
export class References extends Message<References> {
  /**
   * Indicator names used in decision
   *
   * @generated from field: repeated string used_indicators = 1;
   */
  usedIndicators: string[] = [];

  /**
   * Memory case IDs from HelixDB
   *
   * @generated from field: repeated string memory_case_ids = 2;
   */
  memoryCaseIds: string[] = [];

  /**
   * Event IDs that influenced decision
   *
   * @generated from field: repeated string event_ids = 3;
   */
  eventIds: string[] = [];

  constructor(data?: PartialMessage<References>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.References";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "used_indicators",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
    {
      no: 2,
      name: "memory_case_ids",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
    { no: 3, name: "event_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): References {
    return new References().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): References {
    return new References().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): References {
    return new References().fromJsonString(jsonString, options);
  }

  static equals(
    a: References | PlainMessage<References> | undefined,
    b: References | PlainMessage<References> | undefined
  ): boolean {
    return proto3.util.equals(References, a, b);
  }
}

/**
 * Individual decision for an instrument
 *
 * @generated from message cream.v1.Decision
 */
export class Decision extends Message<Decision> {
  /**
   * Target instrument
   *
   * @generated from field: cream.v1.Instrument instrument = 1;
   */
  instrument?: Instrument;

  /**
   * Trading action
   *
   * @generated from field: cream.v1.Action action = 2;
   */
  action = Action.UNSPECIFIED;

  /**
   * Position sizing
   *
   * @generated from field: cream.v1.Size size = 3;
   */
  size?: Size;

  /**
   * Order execution plan
   *
   * @generated from field: cream.v1.OrderPlan order_plan = 4;
   */
  orderPlan?: OrderPlan;

  /**
   * Risk levels (mandatory - always required)
   *
   * @generated from field: cream.v1.RiskLevels risk_levels = 5;
   */
  riskLevels?: RiskLevels;

  /**
   * Strategy family
   *
   * @generated from field: cream.v1.StrategyFamily strategy_family = 6;
   */
  strategyFamily = StrategyFamily.UNSPECIFIED;

  /**
   * Human-readable rationale for the decision
   *
   * @generated from field: string rationale = 7;
   */
  rationale = "";

  /**
   * Confidence score [0.0, 1.0]
   *
   * @generated from field: double confidence = 8;
   */
  confidence = 0;

  /**
   * Supporting references
   *
   * @generated from field: cream.v1.References references = 9;
   */
  references?: References;

  constructor(data?: PartialMessage<Decision>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Decision";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instrument", kind: "message", T: Instrument },
    { no: 2, name: "action", kind: "enum", T: proto3.getEnumType(Action) },
    { no: 3, name: "size", kind: "message", T: Size },
    { no: 4, name: "order_plan", kind: "message", T: OrderPlan },
    { no: 5, name: "risk_levels", kind: "message", T: RiskLevels },
    { no: 6, name: "strategy_family", kind: "enum", T: proto3.getEnumType(StrategyFamily) },
    { no: 7, name: "rationale", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "confidence", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 9, name: "references", kind: "message", T: References },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Decision {
    return new Decision().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Decision {
    return new Decision().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Decision {
    return new Decision().fromJsonString(jsonString, options);
  }

  static equals(
    a: Decision | PlainMessage<Decision> | undefined,
    b: Decision | PlainMessage<Decision> | undefined
  ): boolean {
    return proto3.util.equals(Decision, a, b);
  }
}

/**
 * Complete decision plan for a trading cycle
 *
 * @generated from message cream.v1.DecisionPlan
 */
export class DecisionPlan extends Message<DecisionPlan> {
  /**
   * Unique identifier for this trading cycle
   *
   * @generated from field: string cycle_id = 1;
   */
  cycleId = "";

  /**
   * Timestamp when the decision was made
   *
   * @generated from field: google.protobuf.Timestamp as_of_timestamp = 2;
   */
  asOfTimestamp?: Timestamp;

  /**
   * Trading environment
   *
   * @generated from field: cream.v1.Environment environment = 3;
   */
  environment = Environment.UNSPECIFIED;

  /**
   * List of decisions for this cycle
   *
   * @generated from field: repeated cream.v1.Decision decisions = 4;
   */
  decisions: Decision[] = [];

  /**
   * Optional portfolio-level notes
   *
   * @generated from field: optional string portfolio_notes = 5;
   */
  portfolioNotes?: string;

  constructor(data?: PartialMessage<DecisionPlan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.DecisionPlan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "as_of_timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "environment", kind: "enum", T: proto3.getEnumType(Environment) },
    { no: 4, name: "decisions", kind: "message", T: Decision, repeated: true },
    { no: 5, name: "portfolio_notes", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DecisionPlan {
    return new DecisionPlan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DecisionPlan {
    return new DecisionPlan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DecisionPlan {
    return new DecisionPlan().fromJsonString(jsonString, options);
  }

  static equals(
    a: DecisionPlan | PlainMessage<DecisionPlan> | undefined,
    b: DecisionPlan | PlainMessage<DecisionPlan> | undefined
  ): boolean {
    return proto3.util.equals(DecisionPlan, a, b);
  }
}

/**
 * Risk validation result
 *
 * @generated from message cream.v1.RiskValidationResult
 */
export class RiskValidationResult extends Message<RiskValidationResult> {
  /**
   * Whether the validation passed
   *
   * @generated from field: bool valid = 1;
   */
  valid = false;

  /**
   * Validation errors (blocking issues)
   *
   * @generated from field: repeated string errors = 2;
   */
  errors: string[] = [];

  /**
   * Validation warnings (non-blocking issues)
   *
   * @generated from field: repeated string warnings = 3;
   */
  warnings: string[] = [];

  /**
   * Calculated risk-reward ratio
   *
   * @generated from field: optional double risk_reward_ratio = 4;
   */
  riskRewardRatio?: number;

  constructor(data?: PartialMessage<RiskValidationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.RiskValidationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "warnings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "risk_reward_ratio", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskValidationResult {
    return new RiskValidationResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskValidationResult {
    return new RiskValidationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): RiskValidationResult {
    return new RiskValidationResult().fromJsonString(jsonString, options);
  }

  static equals(
    a: RiskValidationResult | PlainMessage<RiskValidationResult> | undefined,
    b: RiskValidationResult | PlainMessage<RiskValidationResult> | undefined
  ): boolean {
    return proto3.util.equals(RiskValidationResult, a, b);
  }
}

/**
 * Decision plan validation result
 *
 * @generated from message cream.v1.DecisionPlanValidationResult
 */
export class DecisionPlanValidationResult extends Message<DecisionPlanValidationResult> {
  /**
   * Whether the validation passed
   *
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * Validated decision plan (if successful)
   *
   * @generated from field: cream.v1.DecisionPlan decision_plan = 2;
   */
  decisionPlan?: DecisionPlan;

  /**
   * Validation errors
   *
   * @generated from field: repeated string errors = 3;
   */
  errors: string[] = [];

  /**
   * Validation warnings
   *
   * @generated from field: repeated string warnings = 4;
   */
  warnings: string[] = [];

  constructor(data?: PartialMessage<DecisionPlanValidationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.DecisionPlanValidationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "decision_plan", kind: "message", T: DecisionPlan },
    { no: 3, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "warnings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): DecisionPlanValidationResult {
    return new DecisionPlanValidationResult().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): DecisionPlanValidationResult {
    return new DecisionPlanValidationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): DecisionPlanValidationResult {
    return new DecisionPlanValidationResult().fromJsonString(jsonString, options);
  }

  static equals(
    a: DecisionPlanValidationResult | PlainMessage<DecisionPlanValidationResult> | undefined,
    b: DecisionPlanValidationResult | PlainMessage<DecisionPlanValidationResult> | undefined
  ): boolean {
    return proto3.util.equals(DecisionPlanValidationResult, a, b);
  }
}
