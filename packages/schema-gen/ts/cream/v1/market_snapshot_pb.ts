// Cream Trading System - Market Snapshot Schema
// Real-time market data structures for the trading system
//
// NOTE: Using proto3 until Prost (Rust) supports Protobuf Editions.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file cream/v1/market_snapshot.proto (package cream.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Environment, MarketStatus, OptionContract, Regime } from "./common_pb.js";

/**
 * Real-time quote for a symbol
 *
 * @generated from message cream.v1.Quote
 */
export class Quote extends Message<Quote> {
  /**
   * Symbol (e.g., "AAPL")
   *
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * Best bid price
   *
   * @generated from field: double bid = 2;
   */
  bid = 0;

  /**
   * Best ask price
   *
   * @generated from field: double ask = 3;
   */
  ask = 0;

  /**
   * Bid size (shares/contracts)
   *
   * @generated from field: int32 bid_size = 4;
   */
  bidSize = 0;

  /**
   * Ask size (shares/contracts)
   *
   * @generated from field: int32 ask_size = 5;
   */
  askSize = 0;

  /**
   * Last trade price
   *
   * @generated from field: double last = 6;
   */
  last = 0;

  /**
   * Last trade size
   *
   * @generated from field: int32 last_size = 7;
   */
  lastSize = 0;

  /**
   * Cumulative volume
   *
   * @generated from field: int64 volume = 8;
   */
  volume = protoInt64.zero;

  /**
   * Quote timestamp
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 9;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<Quote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Quote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bid", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "ask", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "bid_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "ask_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "last", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "last_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "volume", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Quote {
    return new Quote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Quote {
    return new Quote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Quote {
    return new Quote().fromJsonString(jsonString, options);
  }

  static equals(
    a: Quote | PlainMessage<Quote> | undefined,
    b: Quote | PlainMessage<Quote> | undefined
  ): boolean {
    return proto3.util.equals(Quote, a, b);
  }
}

/**
 * OHLCV candlestick bar
 *
 * @generated from message cream.v1.Bar
 */
export class Bar extends Message<Bar> {
  /**
   * Symbol
   *
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * Bar open time
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  /**
   * Bar timeframe in minutes (1, 5, 15, 60, 240, 1440)
   *
   * @generated from field: int32 timeframe_minutes = 3;
   */
  timeframeMinutes = 0;

  /**
   * Open price
   *
   * @generated from field: double open = 4;
   */
  open = 0;

  /**
   * High price
   *
   * @generated from field: double high = 5;
   */
  high = 0;

  /**
   * Low price
   *
   * @generated from field: double low = 6;
   */
  low = 0;

  /**
   * Close price
   *
   * @generated from field: double close = 7;
   */
  close = 0;

  /**
   * Volume
   *
   * @generated from field: int64 volume = 8;
   */
  volume = protoInt64.zero;

  /**
   * VWAP (volume-weighted average price)
   *
   * @generated from field: optional double vwap = 9;
   */
  vwap?: number;

  /**
   * Number of trades
   *
   * @generated from field: optional int32 trade_count = 10;
   */
  tradeCount?: number;

  constructor(data?: PartialMessage<Bar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Bar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp },
    { no: 3, name: "timeframe_minutes", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "open", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "high", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "low", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "close", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 8, name: "volume", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "vwap", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 10, name: "trade_count", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Bar {
    return new Bar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Bar {
    return new Bar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Bar {
    return new Bar().fromJsonString(jsonString, options);
  }

  static equals(
    a: Bar | PlainMessage<Bar> | undefined,
    b: Bar | PlainMessage<Bar> | undefined
  ): boolean {
    return proto3.util.equals(Bar, a, b);
  }
}

/**
 * Complete market snapshot for a symbol
 *
 * @generated from message cream.v1.SymbolSnapshot
 */
export class SymbolSnapshot extends Message<SymbolSnapshot> {
  /**
   * Symbol
   *
   * @generated from field: string symbol = 1;
   */
  symbol = "";

  /**
   * Current quote
   *
   * @generated from field: cream.v1.Quote quote = 2;
   */
  quote?: Quote;

  /**
   * Latest completed bars (multiple timeframes)
   *
   * @generated from field: repeated cream.v1.Bar bars = 3;
   */
  bars: Bar[] = [];

  /**
   * Market status
   *
   * @generated from field: cream.v1.MarketStatus market_status = 4;
   */
  marketStatus = MarketStatus.UNSPECIFIED;

  /**
   * Daily high
   *
   * @generated from field: double day_high = 5;
   */
  dayHigh = 0;

  /**
   * Daily low
   *
   * @generated from field: double day_low = 6;
   */
  dayLow = 0;

  /**
   * Previous close
   *
   * @generated from field: double prev_close = 7;
   */
  prevClose = 0;

  /**
   * Today's open
   *
   * @generated from field: double open = 8;
   */
  open = 0;

  /**
   * Snapshot timestamp
   *
   * @generated from field: google.protobuf.Timestamp as_of = 9;
   */
  asOf?: Timestamp;

  constructor(data?: PartialMessage<SymbolSnapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.SymbolSnapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quote", kind: "message", T: Quote },
    { no: 3, name: "bars", kind: "message", T: Bar, repeated: true },
    { no: 4, name: "market_status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 5, name: "day_high", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "day_low", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "prev_close", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 8, name: "open", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 9, name: "as_of", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SymbolSnapshot {
    return new SymbolSnapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SymbolSnapshot {
    return new SymbolSnapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SymbolSnapshot {
    return new SymbolSnapshot().fromJsonString(jsonString, options);
  }

  static equals(
    a: SymbolSnapshot | PlainMessage<SymbolSnapshot> | undefined,
    b: SymbolSnapshot | PlainMessage<SymbolSnapshot> | undefined
  ): boolean {
    return proto3.util.equals(SymbolSnapshot, a, b);
  }
}

/**
 * Full market snapshot for multiple symbols
 *
 * @generated from message cream.v1.MarketSnapshot
 */
export class MarketSnapshot extends Message<MarketSnapshot> {
  /**
   * Trading environment
   *
   * @generated from field: cream.v1.Environment environment = 1;
   */
  environment = Environment.UNSPECIFIED;

  /**
   * Snapshot timestamp
   *
   * @generated from field: google.protobuf.Timestamp as_of = 2;
   */
  asOf?: Timestamp;

  /**
   * Market status (overall)
   *
   * @generated from field: cream.v1.MarketStatus market_status = 3;
   */
  marketStatus = MarketStatus.UNSPECIFIED;

  /**
   * Current regime classification
   *
   * @generated from field: cream.v1.Regime regime = 4;
   */
  regime = Regime.UNSPECIFIED;

  /**
   * Symbol snapshots
   *
   * @generated from field: repeated cream.v1.SymbolSnapshot symbols = 5;
   */
  symbols: SymbolSnapshot[] = [];

  constructor(data?: PartialMessage<MarketSnapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.MarketSnapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "environment", kind: "enum", T: proto3.getEnumType(Environment) },
    { no: 2, name: "as_of", kind: "message", T: Timestamp },
    { no: 3, name: "market_status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 4, name: "regime", kind: "enum", T: proto3.getEnumType(Regime) },
    { no: 5, name: "symbols", kind: "message", T: SymbolSnapshot, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketSnapshot {
    return new MarketSnapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketSnapshot {
    return new MarketSnapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketSnapshot {
    return new MarketSnapshot().fromJsonString(jsonString, options);
  }

  static equals(
    a: MarketSnapshot | PlainMessage<MarketSnapshot> | undefined,
    b: MarketSnapshot | PlainMessage<MarketSnapshot> | undefined
  ): boolean {
    return proto3.util.equals(MarketSnapshot, a, b);
  }
}

/**
 * Option quote
 *
 * @generated from message cream.v1.OptionQuote
 */
export class OptionQuote extends Message<OptionQuote> {
  /**
   * Option contract
   *
   * @generated from field: cream.v1.OptionContract contract = 1;
   */
  contract?: OptionContract;

  /**
   * Quote data
   *
   * @generated from field: cream.v1.Quote quote = 2;
   */
  quote?: Quote;

  /**
   * Implied volatility
   *
   * @generated from field: optional double implied_volatility = 3;
   */
  impliedVolatility?: number;

  /**
   * Delta
   *
   * @generated from field: optional double delta = 4;
   */
  delta?: number;

  /**
   * Gamma
   *
   * @generated from field: optional double gamma = 5;
   */
  gamma?: number;

  /**
   * Theta
   *
   * @generated from field: optional double theta = 6;
   */
  theta?: number;

  /**
   * Vega
   *
   * @generated from field: optional double vega = 7;
   */
  vega?: number;

  /**
   * Rho
   *
   * @generated from field: optional double rho = 8;
   */
  rho?: number;

  /**
   * Open interest
   *
   * @generated from field: int32 open_interest = 9;
   */
  openInterest = 0;

  constructor(data?: PartialMessage<OptionQuote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OptionQuote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contract", kind: "message", T: OptionContract },
    { no: 2, name: "quote", kind: "message", T: Quote },
    { no: 3, name: "implied_volatility", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "delta", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 5, name: "gamma", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 6, name: "theta", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "vega", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 8, name: "rho", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 9, name: "open_interest", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionQuote {
    return new OptionQuote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionQuote {
    return new OptionQuote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionQuote {
    return new OptionQuote().fromJsonString(jsonString, options);
  }

  static equals(
    a: OptionQuote | PlainMessage<OptionQuote> | undefined,
    b: OptionQuote | PlainMessage<OptionQuote> | undefined
  ): boolean {
    return proto3.util.equals(OptionQuote, a, b);
  }
}

/**
 * Option chain for an underlying
 *
 * @generated from message cream.v1.OptionChain
 */
export class OptionChain extends Message<OptionChain> {
  /**
   * Underlying symbol
   *
   * @generated from field: string underlying = 1;
   */
  underlying = "";

  /**
   * Underlying price
   *
   * @generated from field: double underlying_price = 2;
   */
  underlyingPrice = 0;

  /**
   * Option quotes
   *
   * @generated from field: repeated cream.v1.OptionQuote options = 3;
   */
  options: OptionQuote[] = [];

  /**
   * Chain timestamp
   *
   * @generated from field: google.protobuf.Timestamp as_of = 4;
   */
  asOf?: Timestamp;

  constructor(data?: PartialMessage<OptionChain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OptionChain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "underlying", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "underlying_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "options", kind: "message", T: OptionQuote, repeated: true },
    { no: 4, name: "as_of", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptionChain {
    return new OptionChain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptionChain {
    return new OptionChain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptionChain {
    return new OptionChain().fromJsonString(jsonString, options);
  }

  static equals(
    a: OptionChain | PlainMessage<OptionChain> | undefined,
    b: OptionChain | PlainMessage<OptionChain> | undefined
  ): boolean {
    return proto3.util.equals(OptionChain, a, b);
  }
}

/**
 * Request to subscribe to market data
 *
 * @generated from message cream.v1.SubscribeMarketDataRequest
 */
export class SubscribeMarketDataRequest extends Message<SubscribeMarketDataRequest> {
  /**
   * Symbols to subscribe to
   *
   * @generated from field: repeated string symbols = 1;
   */
  symbols: string[] = [];

  /**
   * Include option chains
   *
   * @generated from field: bool include_options = 2;
   */
  includeOptions = false;

  /**
   * Bar timeframes to include (in minutes)
   *
   * @generated from field: repeated int32 bar_timeframes = 3;
   */
  barTimeframes: number[] = [];

  constructor(data?: PartialMessage<SubscribeMarketDataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.SubscribeMarketDataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "include_options", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "bar_timeframes", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SubscribeMarketDataRequest {
    return new SubscribeMarketDataRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SubscribeMarketDataRequest {
    return new SubscribeMarketDataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SubscribeMarketDataRequest {
    return new SubscribeMarketDataRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubscribeMarketDataRequest | PlainMessage<SubscribeMarketDataRequest> | undefined,
    b: SubscribeMarketDataRequest | PlainMessage<SubscribeMarketDataRequest> | undefined
  ): boolean {
    return proto3.util.equals(SubscribeMarketDataRequest, a, b);
  }
}

/**
 * Market data update (streamed response)
 *
 * @generated from message cream.v1.SubscribeMarketDataResponse
 */
export class SubscribeMarketDataResponse extends Message<SubscribeMarketDataResponse> {
  /**
   * Update type
   *
   * @generated from oneof cream.v1.SubscribeMarketDataResponse.update
   */
  update:
    | {
        /**
         * @generated from field: cream.v1.Quote quote = 1;
         */
        value: Quote;
        case: "quote";
      }
    | {
        /**
         * @generated from field: cream.v1.Bar bar = 2;
         */
        value: Bar;
        case: "bar";
      }
    | {
        /**
         * @generated from field: cream.v1.OptionQuote option_quote = 3;
         */
        value: OptionQuote;
        case: "optionQuote";
      }
    | {
        /**
         * @generated from field: cream.v1.SymbolSnapshot snapshot = 4;
         */
        value: SymbolSnapshot;
        case: "snapshot";
      }
    | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SubscribeMarketDataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.SubscribeMarketDataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quote", kind: "message", T: Quote, oneof: "update" },
    { no: 2, name: "bar", kind: "message", T: Bar, oneof: "update" },
    { no: 3, name: "option_quote", kind: "message", T: OptionQuote, oneof: "update" },
    { no: 4, name: "snapshot", kind: "message", T: SymbolSnapshot, oneof: "update" },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): SubscribeMarketDataResponse {
    return new SubscribeMarketDataResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): SubscribeMarketDataResponse {
    return new SubscribeMarketDataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SubscribeMarketDataResponse {
    return new SubscribeMarketDataResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubscribeMarketDataResponse | PlainMessage<SubscribeMarketDataResponse> | undefined,
    b: SubscribeMarketDataResponse | PlainMessage<SubscribeMarketDataResponse> | undefined
  ): boolean {
    return proto3.util.equals(SubscribeMarketDataResponse, a, b);
  }
}

/**
 * Request for snapshot
 *
 * @generated from message cream.v1.GetSnapshotRequest
 */
export class GetSnapshotRequest extends Message<GetSnapshotRequest> {
  /**
   * Symbols to get snapshot for
   *
   * @generated from field: repeated string symbols = 1;
   */
  symbols: string[] = [];

  /**
   * Include bars
   *
   * @generated from field: bool include_bars = 2;
   */
  includeBars = false;

  /**
   * Bar timeframes to include
   *
   * @generated from field: repeated int32 bar_timeframes = 3;
   */
  barTimeframes: number[] = [];

  constructor(data?: PartialMessage<GetSnapshotRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetSnapshotRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "symbols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "include_bars", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "bar_timeframes", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSnapshotRequest {
    return new GetSnapshotRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSnapshotRequest {
    return new GetSnapshotRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetSnapshotRequest {
    return new GetSnapshotRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSnapshotRequest | PlainMessage<GetSnapshotRequest> | undefined,
    b: GetSnapshotRequest | PlainMessage<GetSnapshotRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetSnapshotRequest, a, b);
  }
}

/**
 * Response with snapshot
 *
 * @generated from message cream.v1.GetSnapshotResponse
 */
export class GetSnapshotResponse extends Message<GetSnapshotResponse> {
  /**
   * Market snapshot
   *
   * @generated from field: cream.v1.MarketSnapshot snapshot = 1;
   */
  snapshot?: MarketSnapshot;

  constructor(data?: PartialMessage<GetSnapshotResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetSnapshotResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshot", kind: "message", T: MarketSnapshot },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSnapshotResponse {
    return new GetSnapshotResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSnapshotResponse {
    return new GetSnapshotResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetSnapshotResponse {
    return new GetSnapshotResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetSnapshotResponse | PlainMessage<GetSnapshotResponse> | undefined,
    b: GetSnapshotResponse | PlainMessage<GetSnapshotResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetSnapshotResponse, a, b);
  }
}

/**
 * Request for option chain
 *
 * @generated from message cream.v1.GetOptionChainRequest
 */
export class GetOptionChainRequest extends Message<GetOptionChainRequest> {
  /**
   * Underlying symbol
   *
   * @generated from field: string underlying = 1;
   */
  underlying = "";

  /**
   * Expiration dates to include (YYYY-MM-DD format, empty for all)
   *
   * @generated from field: repeated string expirations = 2;
   */
  expirations: string[] = [];

  /**
   * Strike range (min)
   *
   * @generated from field: optional double min_strike = 3;
   */
  minStrike?: number;

  /**
   * Strike range (max)
   *
   * @generated from field: optional double max_strike = 4;
   */
  maxStrike?: number;

  constructor(data?: PartialMessage<GetOptionChainRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetOptionChainRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "underlying", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expirations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "min_strike", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "max_strike", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetOptionChainRequest {
    return new GetOptionChainRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOptionChainRequest {
    return new GetOptionChainRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetOptionChainRequest {
    return new GetOptionChainRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetOptionChainRequest | PlainMessage<GetOptionChainRequest> | undefined,
    b: GetOptionChainRequest | PlainMessage<GetOptionChainRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetOptionChainRequest, a, b);
  }
}

/**
 * Response with option chain
 *
 * @generated from message cream.v1.GetOptionChainResponse
 */
export class GetOptionChainResponse extends Message<GetOptionChainResponse> {
  /**
   * Option chain
   *
   * @generated from field: cream.v1.OptionChain chain = 1;
   */
  chain?: OptionChain;

  constructor(data?: PartialMessage<GetOptionChainResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetOptionChainResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain", kind: "message", T: OptionChain },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetOptionChainResponse {
    return new GetOptionChainResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetOptionChainResponse {
    return new GetOptionChainResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetOptionChainResponse {
    return new GetOptionChainResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetOptionChainResponse | PlainMessage<GetOptionChainResponse> | undefined,
    b: GetOptionChainResponse | PlainMessage<GetOptionChainResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetOptionChainResponse, a, b);
  }
}
