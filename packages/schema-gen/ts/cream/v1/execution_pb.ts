// Cream Trading System - Execution Schema
// Messages for Rust execution engine communication
//
// NOTE: Using proto3 until Prost (Rust) supports Protobuf Editions.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file cream/v1/execution.proto (package cream.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Environment, Instrument, OrderType, TimeInForce } from "./common_pb.js";
import { DecisionPlan } from "./decision_pb.js";

/**
 * Result of a constraint check
 *
 * @generated from enum cream.v1.ConstraintResult
 */
export enum ConstraintResult {
  /**
   * @generated from enum value: CONSTRAINT_RESULT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CONSTRAINT_RESULT_PASS = 1;
   */
  PASS = 1,

  /**
   * @generated from enum value: CONSTRAINT_RESULT_FAIL = 2;
   */
  FAIL = 2,

  /**
   * @generated from enum value: CONSTRAINT_RESULT_WARN = 3;
   */
  WARN = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ConstraintResult)
proto3.util.setEnumType(ConstraintResult, "cream.v1.ConstraintResult", [
  { no: 0, name: "CONSTRAINT_RESULT_UNSPECIFIED" },
  { no: 1, name: "CONSTRAINT_RESULT_PASS" },
  { no: 2, name: "CONSTRAINT_RESULT_FAIL" },
  { no: 3, name: "CONSTRAINT_RESULT_WARN" },
]);

/**
 * Severity of constraint violation
 *
 * @generated from enum cream.v1.ViolationSeverity
 */
export enum ViolationSeverity {
  /**
   * @generated from enum value: VIOLATION_SEVERITY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Informational, does not block
   *
   * @generated from enum value: VIOLATION_SEVERITY_INFO = 1;
   */
  INFO = 1,

  /**
   * Warning, may proceed with caution
   *
   * @generated from enum value: VIOLATION_SEVERITY_WARNING = 2;
   */
  WARNING = 2,

  /**
   * Error, blocks execution
   *
   * @generated from enum value: VIOLATION_SEVERITY_ERROR = 3;
   */
  ERROR = 3,

  /**
   * Critical, requires immediate attention
   *
   * @generated from enum value: VIOLATION_SEVERITY_CRITICAL = 4;
   */
  CRITICAL = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ViolationSeverity)
proto3.util.setEnumType(ViolationSeverity, "cream.v1.ViolationSeverity", [
  { no: 0, name: "VIOLATION_SEVERITY_UNSPECIFIED" },
  { no: 1, name: "VIOLATION_SEVERITY_INFO" },
  { no: 2, name: "VIOLATION_SEVERITY_WARNING" },
  { no: 3, name: "VIOLATION_SEVERITY_ERROR" },
  { no: 4, name: "VIOLATION_SEVERITY_CRITICAL" },
]);

/**
 * Order status
 *
 * @generated from enum cream.v1.OrderStatus
 */
export enum OrderStatus {
  /**
   * @generated from enum value: ORDER_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Order created but not yet sent to broker
   *
   * @generated from enum value: ORDER_STATUS_NEW = 1;
   */
  NEW = 1,

  /**
   * Sent to broker, awaiting acknowledgment
   *
   * @generated from enum value: ORDER_STATUS_PENDING = 2;
   */
  PENDING = 2,

  /**
   * Accepted by broker
   *
   * @generated from enum value: ORDER_STATUS_ACCEPTED = 3;
   */
  ACCEPTED = 3,

  /**
   * Partially filled
   *
   * @generated from enum value: ORDER_STATUS_PARTIAL_FILL = 4;
   */
  PARTIAL_FILL = 4,

  /**
   * Completely filled
   *
   * @generated from enum value: ORDER_STATUS_FILLED = 5;
   */
  FILLED = 5,

  /**
   * Cancelled by user or system
   *
   * @generated from enum value: ORDER_STATUS_CANCELLED = 6;
   */
  CANCELLED = 6,

  /**
   * Rejected by broker
   *
   * @generated from enum value: ORDER_STATUS_REJECTED = 7;
   */
  REJECTED = 7,

  /**
   * Expired (e.g., DAY order at close)
   *
   * @generated from enum value: ORDER_STATUS_EXPIRED = 8;
   */
  EXPIRED = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderStatus)
proto3.util.setEnumType(OrderStatus, "cream.v1.OrderStatus", [
  { no: 0, name: "ORDER_STATUS_UNSPECIFIED" },
  { no: 1, name: "ORDER_STATUS_NEW" },
  { no: 2, name: "ORDER_STATUS_PENDING" },
  { no: 3, name: "ORDER_STATUS_ACCEPTED" },
  { no: 4, name: "ORDER_STATUS_PARTIAL_FILL" },
  { no: 5, name: "ORDER_STATUS_FILLED" },
  { no: 6, name: "ORDER_STATUS_CANCELLED" },
  { no: 7, name: "ORDER_STATUS_REJECTED" },
  { no: 8, name: "ORDER_STATUS_EXPIRED" },
]);

/**
 * Order side
 *
 * @generated from enum cream.v1.OrderSide
 */
export enum OrderSide {
  /**
   * @generated from enum value: ORDER_SIDE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ORDER_SIDE_BUY = 1;
   */
  BUY = 1,

  /**
   * @generated from enum value: ORDER_SIDE_SELL = 2;
   */
  SELL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderSide)
proto3.util.setEnumType(OrderSide, "cream.v1.OrderSide", [
  { no: 0, name: "ORDER_SIDE_UNSPECIFIED" },
  { no: 1, name: "ORDER_SIDE_BUY" },
  { no: 2, name: "ORDER_SIDE_SELL" },
]);

/**
 * Individual constraint check result
 *
 * @generated from message cream.v1.ConstraintCheck
 */
export class ConstraintCheck extends Message<ConstraintCheck> {
  /**
   * Name of the constraint
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Result of the check
   *
   * @generated from field: cream.v1.ConstraintResult result = 2;
   */
  result = ConstraintResult.UNSPECIFIED;

  /**
   * Description of the constraint
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Actual value that was checked
   *
   * @generated from field: optional double actual_value = 4;
   */
  actualValue?: number;

  /**
   * Threshold that was applied
   *
   * @generated from field: optional double threshold = 5;
   */
  threshold?: number;

  constructor(data?: PartialMessage<ConstraintCheck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.ConstraintCheck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "result", kind: "enum", T: proto3.getEnumType(ConstraintResult) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "actual_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 5, name: "threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConstraintCheck {
    return new ConstraintCheck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConstraintCheck {
    return new ConstraintCheck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConstraintCheck {
    return new ConstraintCheck().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConstraintCheck | PlainMessage<ConstraintCheck> | undefined,
    b: ConstraintCheck | PlainMessage<ConstraintCheck> | undefined
  ): boolean {
    return proto3.util.equals(ConstraintCheck, a, b);
  }
}

/**
 * Request to validate a decision plan against constraints
 *
 * @generated from message cream.v1.CheckConstraintsRequest
 */
export class CheckConstraintsRequest extends Message<CheckConstraintsRequest> {
  /**
   * Decision plan to validate
   *
   * @generated from field: cream.v1.DecisionPlan decision_plan = 1;
   */
  decisionPlan?: DecisionPlan;

  /**
   * Current account state
   *
   * @generated from field: cream.v1.AccountState account_state = 2;
   */
  accountState?: AccountState;

  /**
   * Current positions
   *
   * @generated from field: repeated cream.v1.Position positions = 3;
   */
  positions: Position[] = [];

  constructor(data?: PartialMessage<CheckConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.CheckConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "decision_plan", kind: "message", T: DecisionPlan },
    { no: 2, name: "account_state", kind: "message", T: AccountState },
    { no: 3, name: "positions", kind: "message", T: Position, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CheckConstraintsRequest {
    return new CheckConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CheckConstraintsRequest {
    return new CheckConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CheckConstraintsRequest {
    return new CheckConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckConstraintsRequest | PlainMessage<CheckConstraintsRequest> | undefined,
    b: CheckConstraintsRequest | PlainMessage<CheckConstraintsRequest> | undefined
  ): boolean {
    return proto3.util.equals(CheckConstraintsRequest, a, b);
  }
}

/**
 * Response from constraint validation
 *
 * @generated from message cream.v1.CheckConstraintsResponse
 */
export class CheckConstraintsResponse extends Message<CheckConstraintsResponse> {
  /**
   * Overall result
   *
   * @generated from field: bool approved = 1;
   */
  approved = false;

  /**
   * Individual constraint results
   *
   * @generated from field: repeated cream.v1.ConstraintCheck checks = 2;
   */
  checks: ConstraintCheck[] = [];

  /**
   * Detailed violations (when not approved)
   *
   * @generated from field: repeated cream.v1.ConstraintViolation violations = 3;
   */
  violations: ConstraintViolation[] = [];

  /**
   * Timestamp of validation
   *
   * @generated from field: google.protobuf.Timestamp validated_at = 4;
   */
  validatedAt?: Timestamp;

  /**
   * Rejection reason (if not approved)
   *
   * @generated from field: optional string rejection_reason = 5;
   */
  rejectionReason?: string;

  constructor(data?: PartialMessage<CheckConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.CheckConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "approved", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "checks", kind: "message", T: ConstraintCheck, repeated: true },
    { no: 3, name: "violations", kind: "message", T: ConstraintViolation, repeated: true },
    { no: 4, name: "validated_at", kind: "message", T: Timestamp },
    { no: 5, name: "rejection_reason", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): CheckConstraintsResponse {
    return new CheckConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): CheckConstraintsResponse {
    return new CheckConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CheckConstraintsResponse {
    return new CheckConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CheckConstraintsResponse | PlainMessage<CheckConstraintsResponse> | undefined,
    b: CheckConstraintsResponse | PlainMessage<CheckConstraintsResponse> | undefined
  ): boolean {
    return proto3.util.equals(CheckConstraintsResponse, a, b);
  }
}

/**
 * Detailed constraint violation
 *
 * @generated from message cream.v1.ConstraintViolation
 */
export class ConstraintViolation extends Message<ConstraintViolation> {
  /**
   * Violation code (e.g., "MAX_POSITION_SIZE", "INSUFFICIENT_MARGIN")
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * Severity level
   *
   * @generated from field: cream.v1.ViolationSeverity severity = 2;
   */
  severity = ViolationSeverity.UNSPECIFIED;

  /**
   * Human-readable description
   *
   * @generated from field: string message = 3;
   */
  message = "";

  /**
   * Instrument that violated (if applicable)
   *
   * @generated from field: optional string instrument_id = 4;
   */
  instrumentId?: string;

  /**
   * Field path that violated (e.g., "size.quantity")
   *
   * @generated from field: optional string field_path = 5;
   */
  fieldPath?: string;

  /**
   * Observed value that triggered violation
   *
   * @generated from field: optional double observed_value = 6;
   */
  observedValue?: number;

  /**
   * Limit that was exceeded
   *
   * @generated from field: optional double limit_value = 7;
   */
  limitValue?: number;

  /**
   * Constraint name that was violated
   *
   * @generated from field: string constraint_name = 8;
   */
  constraintName = "";

  constructor(data?: PartialMessage<ConstraintViolation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.ConstraintViolation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "severity", kind: "enum", T: proto3.getEnumType(ViolationSeverity) },
    { no: 3, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "instrument_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "observed_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "limit_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 8, name: "constraint_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConstraintViolation {
    return new ConstraintViolation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConstraintViolation {
    return new ConstraintViolation().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): ConstraintViolation {
    return new ConstraintViolation().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConstraintViolation | PlainMessage<ConstraintViolation> | undefined,
    b: ConstraintViolation | PlainMessage<ConstraintViolation> | undefined
  ): boolean {
    return proto3.util.equals(ConstraintViolation, a, b);
  }
}

/**
 * Current account state
 *
 * @generated from message cream.v1.AccountState
 */
export class AccountState extends Message<AccountState> {
  /**
   * Account identifier
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * Total account equity
   *
   * @generated from field: double equity = 2;
   */
  equity = 0;

  /**
   * Available cash for trading
   *
   * @generated from field: double buying_power = 3;
   */
  buyingPower = 0;

  /**
   * Current margin used
   *
   * @generated from field: double margin_used = 4;
   */
  marginUsed = 0;

  /**
   * Day trade count (for PDT rule)
   *
   * @generated from field: int32 day_trade_count = 5;
   */
  dayTradeCount = 0;

  /**
   * Whether pattern day trader rules apply
   *
   * @generated from field: bool is_pdt_restricted = 6;
   */
  isPdtRestricted = false;

  /**
   * Timestamp of state snapshot
   *
   * @generated from field: google.protobuf.Timestamp as_of = 7;
   */
  asOf?: Timestamp;

  constructor(data?: PartialMessage<AccountState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.AccountState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "equity", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "buying_power", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "margin_used", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "day_trade_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "is_pdt_restricted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "as_of", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountState {
    return new AccountState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountState {
    return new AccountState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountState {
    return new AccountState().fromJsonString(jsonString, options);
  }

  static equals(
    a: AccountState | PlainMessage<AccountState> | undefined,
    b: AccountState | PlainMessage<AccountState> | undefined
  ): boolean {
    return proto3.util.equals(AccountState, a, b);
  }
}

/**
 * Current position
 *
 * @generated from message cream.v1.Position
 */
export class Position extends Message<Position> {
  /**
   * Instrument
   *
   * @generated from field: cream.v1.Instrument instrument = 1;
   */
  instrument?: Instrument;

  /**
   * Quantity held (signed: positive=long, negative=short)
   *
   * @generated from field: int32 quantity = 2;
   */
  quantity = 0;

  /**
   * Average entry price
   *
   * @generated from field: double avg_entry_price = 3;
   */
  avgEntryPrice = 0;

  /**
   * Current market value
   *
   * @generated from field: double market_value = 4;
   */
  marketValue = 0;

  /**
   * Unrealized P&L
   *
   * @generated from field: double unrealized_pnl = 5;
   */
  unrealizedPnl = 0;

  /**
   * Unrealized P&L percentage
   *
   * @generated from field: double unrealized_pnl_pct = 6;
   */
  unrealizedPnlPct = 0;

  /**
   * Cost basis
   *
   * @generated from field: double cost_basis = 7;
   */
  costBasis = 0;

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instrument", kind: "message", T: Instrument },
    { no: 2, name: "quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "avg_entry_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "market_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "unrealized_pnl", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "unrealized_pnl_pct", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 7, name: "cost_basis", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(
    a: Position | PlainMessage<Position> | undefined,
    b: Position | PlainMessage<Position> | undefined
  ): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * Request to submit an order
 *
 * @generated from message cream.v1.SubmitOrderRequest
 */
export class SubmitOrderRequest extends Message<SubmitOrderRequest> {
  /**
   * Instrument to trade
   *
   * @generated from field: cream.v1.Instrument instrument = 1;
   */
  instrument?: Instrument;

  /**
   * Buy or sell
   *
   * @generated from field: cream.v1.OrderSide side = 2;
   */
  side = OrderSide.UNSPECIFIED;

  /**
   * Quantity
   *
   * @generated from field: int32 quantity = 3;
   */
  quantity = 0;

  /**
   * Order type
   *
   * @generated from field: cream.v1.OrderType order_type = 4;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * Limit price (required for limit orders)
   *
   * @generated from field: optional double limit_price = 5;
   */
  limitPrice?: number;

  /**
   * Time in force
   *
   * @generated from field: cream.v1.TimeInForce time_in_force = 6;
   */
  timeInForce = TimeInForce.UNSPECIFIED;

  /**
   * Client order ID for tracking
   *
   * @generated from field: string client_order_id = 7;
   */
  clientOrderId = "";

  /**
   * Reference to decision cycle
   *
   * @generated from field: string cycle_id = 8;
   */
  cycleId = "";

  constructor(data?: PartialMessage<SubmitOrderRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.SubmitOrderRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instrument", kind: "message", T: Instrument },
    { no: 2, name: "side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 3, name: "quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 5, name: "limit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 6, name: "time_in_force", kind: "enum", T: proto3.getEnumType(TimeInForce) },
    { no: 7, name: "client_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitOrderRequest {
    return new SubmitOrderRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitOrderRequest {
    return new SubmitOrderRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SubmitOrderRequest {
    return new SubmitOrderRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubmitOrderRequest | PlainMessage<SubmitOrderRequest> | undefined,
    b: SubmitOrderRequest | PlainMessage<SubmitOrderRequest> | undefined
  ): boolean {
    return proto3.util.equals(SubmitOrderRequest, a, b);
  }
}

/**
 * Response from order submission
 *
 * @generated from message cream.v1.SubmitOrderResponse
 */
export class SubmitOrderResponse extends Message<SubmitOrderResponse> {
  /**
   * Broker-assigned order ID
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  /**
   * Client order ID (echoed back)
   *
   * @generated from field: string client_order_id = 2;
   */
  clientOrderId = "";

  /**
   * Current order status
   *
   * @generated from field: cream.v1.OrderStatus status = 3;
   */
  status = OrderStatus.UNSPECIFIED;

  /**
   * Submission timestamp
   *
   * @generated from field: google.protobuf.Timestamp submitted_at = 4;
   */
  submittedAt?: Timestamp;

  /**
   * Error message if rejected
   *
   * @generated from field: optional string error_message = 5;
   */
  errorMessage?: string;

  constructor(data?: PartialMessage<SubmitOrderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.SubmitOrderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "client_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(OrderStatus) },
    { no: 4, name: "submitted_at", kind: "message", T: Timestamp },
    { no: 5, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubmitOrderResponse {
    return new SubmitOrderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubmitOrderResponse {
    return new SubmitOrderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): SubmitOrderResponse {
    return new SubmitOrderResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SubmitOrderResponse | PlainMessage<SubmitOrderResponse> | undefined,
    b: SubmitOrderResponse | PlainMessage<SubmitOrderResponse> | undefined
  ): boolean {
    return proto3.util.equals(SubmitOrderResponse, a, b);
  }
}

/**
 * Order execution acknowledgment
 *
 * @generated from message cream.v1.ExecutionAck
 */
export class ExecutionAck extends Message<ExecutionAck> {
  /**
   * Decision cycle ID
   *
   * @generated from field: string cycle_id = 1;
   */
  cycleId = "";

  /**
   * Environment the execution ran in
   *
   * @generated from field: cream.v1.Environment environment = 2;
   */
  environment = Environment.UNSPECIFIED;

  /**
   * Timestamp of acknowledgment
   *
   * @generated from field: google.protobuf.Timestamp ack_time = 3;
   */
  ackTime?: Timestamp;

  /**
   * Orders that were executed
   *
   * @generated from field: repeated cream.v1.OrderState orders = 4;
   */
  orders: OrderState[] = [];

  /**
   * Errors encountered during execution
   *
   * @generated from field: repeated cream.v1.ExecutionError errors = 5;
   */
  errors: ExecutionError[] = [];

  constructor(data?: PartialMessage<ExecutionAck>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.ExecutionAck";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "environment", kind: "enum", T: proto3.getEnumType(Environment) },
    { no: 3, name: "ack_time", kind: "message", T: Timestamp },
    { no: 4, name: "orders", kind: "message", T: OrderState, repeated: true },
    { no: 5, name: "errors", kind: "message", T: ExecutionError, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionAck {
    return new ExecutionAck().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionAck {
    return new ExecutionAck().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionAck {
    return new ExecutionAck().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExecutionAck | PlainMessage<ExecutionAck> | undefined,
    b: ExecutionAck | PlainMessage<ExecutionAck> | undefined
  ): boolean {
    return proto3.util.equals(ExecutionAck, a, b);
  }
}

/**
 * Complete order state for tracking
 *
 * @generated from message cream.v1.OrderState
 */
export class OrderState extends Message<OrderState> {
  /**
   * Internal order ID
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  /**
   * Broker-assigned order ID
   *
   * @generated from field: string broker_order_id = 2;
   */
  brokerOrderId = "";

  /**
   * Client order ID
   *
   * @generated from field: string client_order_id = 3;
   */
  clientOrderId = "";

  /**
   * Whether this is a multi-leg order
   *
   * @generated from field: bool is_multi_leg = 4;
   */
  isMultiLeg = false;

  /**
   * Leg states (for multi-leg orders)
   *
   * @generated from field: repeated cream.v1.OrderLegState legs = 5;
   */
  legs: OrderLegState[] = [];

  /**
   * Current status
   *
   * @generated from field: cream.v1.OrderStatus status = 6;
   */
  status = OrderStatus.UNSPECIFIED;

  /**
   * Order side
   *
   * @generated from field: cream.v1.OrderSide side = 7;
   */
  side = OrderSide.UNSPECIFIED;

  /**
   * Order type
   *
   * @generated from field: cream.v1.OrderType order_type = 8;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * Instrument (for single-leg orders)
   *
   * @generated from field: cream.v1.Instrument instrument = 9;
   */
  instrument?: Instrument;

  /**
   * Requested quantity
   *
   * @generated from field: int32 requested_quantity = 10;
   */
  requestedQuantity = 0;

  /**
   * Filled quantity
   *
   * @generated from field: int32 filled_quantity = 11;
   */
  filledQuantity = 0;

  /**
   * Average fill price
   *
   * @generated from field: double avg_fill_price = 12;
   */
  avgFillPrice = 0;

  /**
   * Limit price (if applicable)
   *
   * @generated from field: optional double limit_price = 13;
   */
  limitPrice?: number;

  /**
   * Stop price (if applicable)
   *
   * @generated from field: optional double stop_price = 14;
   */
  stopPrice?: number;

  /**
   * Time in force
   *
   * @generated from field: cream.v1.TimeInForce time_in_force = 15;
   */
  timeInForce = TimeInForce.UNSPECIFIED;

  /**
   * Submission timestamp
   *
   * @generated from field: google.protobuf.Timestamp submitted_at = 16;
   */
  submittedAt?: Timestamp;

  /**
   * Last update timestamp
   *
   * @generated from field: google.protobuf.Timestamp last_update_at = 17;
   */
  lastUpdateAt?: Timestamp;

  /**
   * Commission charged
   *
   * @generated from field: double commission = 18;
   */
  commission = 0;

  /**
   * Reference to decision cycle
   *
   * @generated from field: string cycle_id = 19;
   */
  cycleId = "";

  /**
   * Status message from broker
   *
   * @generated from field: string status_message = 20;
   */
  statusMessage = "";

  constructor(data?: PartialMessage<OrderState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OrderState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "broker_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "client_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "is_multi_leg", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "legs", kind: "message", T: OrderLegState, repeated: true },
    { no: 6, name: "status", kind: "enum", T: proto3.getEnumType(OrderStatus) },
    { no: 7, name: "side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 8, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 9, name: "instrument", kind: "message", T: Instrument },
    { no: 10, name: "requested_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "filled_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 12, name: "avg_fill_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 13, name: "limit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 14, name: "stop_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 15, name: "time_in_force", kind: "enum", T: proto3.getEnumType(TimeInForce) },
    { no: 16, name: "submitted_at", kind: "message", T: Timestamp },
    { no: 17, name: "last_update_at", kind: "message", T: Timestamp },
    { no: 18, name: "commission", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 19, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 20, name: "status_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderState {
    return new OrderState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderState {
    return new OrderState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderState {
    return new OrderState().fromJsonString(jsonString, options);
  }

  static equals(
    a: OrderState | PlainMessage<OrderState> | undefined,
    b: OrderState | PlainMessage<OrderState> | undefined
  ): boolean {
    return proto3.util.equals(OrderState, a, b);
  }
}

/**
 * State of a single leg in a multi-leg order
 *
 * @generated from message cream.v1.OrderLegState
 */
export class OrderLegState extends Message<OrderLegState> {
  /**
   * Leg identifier within the order
   *
   * @generated from field: string leg_id = 1;
   */
  legId = "";

  /**
   * Instrument for this leg
   *
   * @generated from field: cream.v1.Instrument instrument = 2;
   */
  instrument?: Instrument;

  /**
   * Side for this leg (BUY or SELL)
   *
   * @generated from field: cream.v1.OrderSide side = 3;
   */
  side = OrderSide.UNSPECIFIED;

  /**
   * Requested quantity for this leg
   *
   * @generated from field: int32 quantity = 4;
   */
  quantity = 0;

  /**
   * Order type for this leg
   *
   * @generated from field: cream.v1.OrderType order_type = 5;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * Limit price for this leg (if applicable)
   *
   * @generated from field: optional double limit_price = 6;
   */
  limitPrice?: number;

  /**
   * Status of this leg
   *
   * @generated from field: cream.v1.OrderStatus status = 7;
   */
  status = OrderStatus.UNSPECIFIED;

  /**
   * Filled quantity for this leg
   *
   * @generated from field: int32 filled_quantity = 8;
   */
  filledQuantity = 0;

  /**
   * Average fill price for this leg
   *
   * @generated from field: double avg_fill_price = 9;
   */
  avgFillPrice = 0;

  /**
   * Last update timestamp for this leg
   *
   * @generated from field: google.protobuf.Timestamp last_update_at = 10;
   */
  lastUpdateAt?: Timestamp;

  constructor(data?: PartialMessage<OrderLegState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.OrderLegState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "leg_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "instrument", kind: "message", T: Instrument },
    { no: 3, name: "side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 4, name: "quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 6, name: "limit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 7, name: "status", kind: "enum", T: proto3.getEnumType(OrderStatus) },
    { no: 8, name: "filled_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "avg_fill_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 10, name: "last_update_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderLegState {
    return new OrderLegState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderLegState {
    return new OrderLegState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderLegState {
    return new OrderLegState().fromJsonString(jsonString, options);
  }

  static equals(
    a: OrderLegState | PlainMessage<OrderLegState> | undefined,
    b: OrderLegState | PlainMessage<OrderLegState> | undefined
  ): boolean {
    return proto3.util.equals(OrderLegState, a, b);
  }
}

/**
 * Execution error
 *
 * @generated from message cream.v1.ExecutionError
 */
export class ExecutionError extends Message<ExecutionError> {
  /**
   * Error code
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * Human-readable error message
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * Instrument that caused the error (if applicable)
   *
   * @generated from field: optional string instrument_id = 3;
   */
  instrumentId?: string;

  /**
   * Order ID that caused the error (if applicable)
   *
   * @generated from field: optional string order_id = 4;
   */
  orderId?: string;

  /**
   * Whether this error is retryable
   *
   * @generated from field: bool retryable = 5;
   */
  retryable = false;

  /**
   * Suggested action
   *
   * @generated from field: string suggested_action = 6;
   */
  suggestedAction = "";

  constructor(data?: PartialMessage<ExecutionError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.ExecutionError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instrument_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "retryable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "suggested_action", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionError {
    return new ExecutionError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJsonString(jsonString, options);
  }

  static equals(
    a: ExecutionError | PlainMessage<ExecutionError> | undefined,
    b: ExecutionError | PlainMessage<ExecutionError> | undefined
  ): boolean {
    return proto3.util.equals(ExecutionError, a, b);
  }
}

/**
 * Request to get order state
 *
 * @generated from message cream.v1.GetOrderStateRequest
 */
export class GetOrderStateRequest extends Message<GetOrderStateRequest> {
  /**
   * Order ID to query (can be broker order ID or internal order ID)
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  constructor(data?: PartialMessage<GetOrderStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetOrderStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrderStateRequest {
    return new GetOrderStateRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrderStateRequest {
    return new GetOrderStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetOrderStateRequest {
    return new GetOrderStateRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetOrderStateRequest | PlainMessage<GetOrderStateRequest> | undefined,
    b: GetOrderStateRequest | PlainMessage<GetOrderStateRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetOrderStateRequest, a, b);
  }
}

/**
 * Response with order state
 *
 * @generated from message cream.v1.GetOrderStateResponse
 */
export class GetOrderStateResponse extends Message<GetOrderStateResponse> {
  /**
   * Order ID
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  /**
   * Broker order ID
   *
   * @generated from field: string broker_order_id = 2;
   */
  brokerOrderId = "";

  /**
   * Instrument
   *
   * @generated from field: cream.v1.Instrument instrument = 3;
   */
  instrument?: Instrument;

  /**
   * Current status
   *
   * @generated from field: cream.v1.OrderStatus status = 4;
   */
  status = OrderStatus.UNSPECIFIED;

  /**
   * Order side
   *
   * @generated from field: cream.v1.OrderSide side = 5;
   */
  side = OrderSide.UNSPECIFIED;

  /**
   * Order type
   *
   * @generated from field: cream.v1.OrderType order_type = 6;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * Requested quantity
   *
   * @generated from field: int32 requested_quantity = 7;
   */
  requestedQuantity = 0;

  /**
   * Filled quantity
   *
   * @generated from field: int32 filled_quantity = 8;
   */
  filledQuantity = 0;

  /**
   * Average fill price
   *
   * @generated from field: double avg_fill_price = 9;
   */
  avgFillPrice = 0;

  /**
   * Limit price (if applicable)
   *
   * @generated from field: optional double limit_price = 10;
   */
  limitPrice?: number;

  /**
   * Stop price (if applicable)
   *
   * @generated from field: optional double stop_price = 11;
   */
  stopPrice?: number;

  /**
   * Submission timestamp
   *
   * @generated from field: google.protobuf.Timestamp submitted_at = 12;
   */
  submittedAt?: Timestamp;

  /**
   * Last update timestamp
   *
   * @generated from field: google.protobuf.Timestamp last_update_at = 13;
   */
  lastUpdateAt?: Timestamp;

  /**
   * Status message from broker
   *
   * @generated from field: string status_message = 14;
   */
  statusMessage = "";

  constructor(data?: PartialMessage<GetOrderStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetOrderStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "broker_order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "instrument", kind: "message", T: Instrument },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(OrderStatus) },
    { no: 5, name: "side", kind: "enum", T: proto3.getEnumType(OrderSide) },
    { no: 6, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 7, name: "requested_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "filled_quantity", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 9, name: "avg_fill_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 10, name: "limit_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 11, name: "stop_price", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 12, name: "submitted_at", kind: "message", T: Timestamp },
    { no: 13, name: "last_update_at", kind: "message", T: Timestamp },
    { no: 14, name: "status_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetOrderStateResponse {
    return new GetOrderStateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrderStateResponse {
    return new GetOrderStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetOrderStateResponse {
    return new GetOrderStateResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetOrderStateResponse | PlainMessage<GetOrderStateResponse> | undefined,
    b: GetOrderStateResponse | PlainMessage<GetOrderStateResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetOrderStateResponse, a, b);
  }
}

/**
 * Request to cancel an order
 *
 * @generated from message cream.v1.CancelOrderRequest
 */
export class CancelOrderRequest extends Message<CancelOrderRequest> {
  /**
   * Order ID to cancel (can be broker order ID or internal order ID)
   *
   * @generated from field: string order_id = 1;
   */
  orderId = "";

  constructor(data?: PartialMessage<CancelOrderRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.CancelOrderRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelOrderRequest {
    return new CancelOrderRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelOrderRequest {
    return new CancelOrderRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CancelOrderRequest {
    return new CancelOrderRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CancelOrderRequest | PlainMessage<CancelOrderRequest> | undefined,
    b: CancelOrderRequest | PlainMessage<CancelOrderRequest> | undefined
  ): boolean {
    return proto3.util.equals(CancelOrderRequest, a, b);
  }
}

/**
 * Response from cancel request
 *
 * @generated from message cream.v1.CancelOrderResponse
 */
export class CancelOrderResponse extends Message<CancelOrderResponse> {
  /**
   * Whether cancel request was accepted
   *
   * @generated from field: bool accepted = 1;
   */
  accepted = false;

  /**
   * Order ID that was canceled
   *
   * @generated from field: string order_id = 2;
   */
  orderId = "";

  /**
   * Current order status after cancel request
   *
   * @generated from field: cream.v1.OrderStatus status = 3;
   */
  status = OrderStatus.UNSPECIFIED;

  /**
   * Error message if cancel was rejected
   *
   * @generated from field: optional string error_message = 4;
   */
  errorMessage?: string;

  constructor(data?: PartialMessage<CancelOrderResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.CancelOrderResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accepted", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "order_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "status", kind: "enum", T: proto3.getEnumType(OrderStatus) },
    { no: 4, name: "error_message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelOrderResponse {
    return new CancelOrderResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelOrderResponse {
    return new CancelOrderResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): CancelOrderResponse {
    return new CancelOrderResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CancelOrderResponse | PlainMessage<CancelOrderResponse> | undefined,
    b: CancelOrderResponse | PlainMessage<CancelOrderResponse> | undefined
  ): boolean {
    return proto3.util.equals(CancelOrderResponse, a, b);
  }
}

/**
 * Request to stream executions
 *
 * @generated from message cream.v1.StreamExecutionsRequest
 */
export class StreamExecutionsRequest extends Message<StreamExecutionsRequest> {
  /**
   * Filter by cycle ID (optional)
   *
   * @generated from field: optional string cycle_id = 1;
   */
  cycleId?: string;

  /**
   * Filter by order IDs (optional)
   *
   * @generated from field: repeated string order_ids = 2;
   */
  orderIds: string[] = [];

  constructor(data?: PartialMessage<StreamExecutionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.StreamExecutionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cycle_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "order_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): StreamExecutionsRequest {
    return new StreamExecutionsRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): StreamExecutionsRequest {
    return new StreamExecutionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): StreamExecutionsRequest {
    return new StreamExecutionsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: StreamExecutionsRequest | PlainMessage<StreamExecutionsRequest> | undefined,
    b: StreamExecutionsRequest | PlainMessage<StreamExecutionsRequest> | undefined
  ): boolean {
    return proto3.util.equals(StreamExecutionsRequest, a, b);
  }
}

/**
 * Response with execution update (streamed)
 *
 * @generated from message cream.v1.StreamExecutionsResponse
 */
export class StreamExecutionsResponse extends Message<StreamExecutionsResponse> {
  /**
   * Execution acknowledgment
   *
   * @generated from field: cream.v1.ExecutionAck execution = 1;
   */
  execution?: ExecutionAck;

  constructor(data?: PartialMessage<StreamExecutionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.StreamExecutionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "execution", kind: "message", T: ExecutionAck },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): StreamExecutionsResponse {
    return new StreamExecutionsResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): StreamExecutionsResponse {
    return new StreamExecutionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): StreamExecutionsResponse {
    return new StreamExecutionsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: StreamExecutionsResponse | PlainMessage<StreamExecutionsResponse> | undefined,
    b: StreamExecutionsResponse | PlainMessage<StreamExecutionsResponse> | undefined
  ): boolean {
    return proto3.util.equals(StreamExecutionsResponse, a, b);
  }
}

/**
 * Request for account state
 *
 * @generated from message cream.v1.GetAccountStateRequest
 */
export class GetAccountStateRequest extends Message<GetAccountStateRequest> {
  /**
   * Account ID (uses default if not specified)
   *
   * @generated from field: optional string account_id = 1;
   */
  accountId?: string;

  constructor(data?: PartialMessage<GetAccountStateRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetAccountStateRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetAccountStateRequest {
    return new GetAccountStateRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetAccountStateRequest {
    return new GetAccountStateRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetAccountStateRequest {
    return new GetAccountStateRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetAccountStateRequest | PlainMessage<GetAccountStateRequest> | undefined,
    b: GetAccountStateRequest | PlainMessage<GetAccountStateRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetAccountStateRequest, a, b);
  }
}

/**
 * Response with account state
 *
 * @generated from message cream.v1.GetAccountStateResponse
 */
export class GetAccountStateResponse extends Message<GetAccountStateResponse> {
  /**
   * Current account state
   *
   * @generated from field: cream.v1.AccountState account_state = 1;
   */
  accountState?: AccountState;

  constructor(data?: PartialMessage<GetAccountStateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetAccountStateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_state", kind: "message", T: AccountState },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>
  ): GetAccountStateResponse {
    return new GetAccountStateResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>
  ): GetAccountStateResponse {
    return new GetAccountStateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetAccountStateResponse {
    return new GetAccountStateResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetAccountStateResponse | PlainMessage<GetAccountStateResponse> | undefined,
    b: GetAccountStateResponse | PlainMessage<GetAccountStateResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetAccountStateResponse, a, b);
  }
}

/**
 * Request for positions
 *
 * @generated from message cream.v1.GetPositionsRequest
 */
export class GetPositionsRequest extends Message<GetPositionsRequest> {
  /**
   * Account ID (uses default if not specified)
   *
   * @generated from field: optional string account_id = 1;
   */
  accountId?: string;

  /**
   * Filter by symbols (optional)
   *
   * @generated from field: repeated string symbols = 2;
   */
  symbols: string[] = [];

  constructor(data?: PartialMessage<GetPositionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetPositionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "symbols", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPositionsRequest {
    return new GetPositionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPositionsRequest {
    return new GetPositionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetPositionsRequest {
    return new GetPositionsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetPositionsRequest | PlainMessage<GetPositionsRequest> | undefined,
    b: GetPositionsRequest | PlainMessage<GetPositionsRequest> | undefined
  ): boolean {
    return proto3.util.equals(GetPositionsRequest, a, b);
  }
}

/**
 * Response with positions
 *
 * @generated from message cream.v1.GetPositionsResponse
 */
export class GetPositionsResponse extends Message<GetPositionsResponse> {
  /**
   * Current positions
   *
   * @generated from field: repeated cream.v1.Position positions = 1;
   */
  positions: Position[] = [];

  /**
   * Timestamp of snapshot
   *
   * @generated from field: google.protobuf.Timestamp as_of = 2;
   */
  asOf?: Timestamp;

  constructor(data?: PartialMessage<GetPositionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cream.v1.GetPositionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "positions", kind: "message", T: Position, repeated: true },
    { no: 2, name: "as_of", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPositionsResponse {
    return new GetPositionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPositionsResponse {
    return new GetPositionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>
  ): GetPositionsResponse {
    return new GetPositionsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetPositionsResponse | PlainMessage<GetPositionsResponse> | undefined,
    b: GetPositionsResponse | PlainMessage<GetPositionsResponse> | undefined
  ): boolean {
    return proto3.util.equals(GetPositionsResponse, a, b);
  }
}
