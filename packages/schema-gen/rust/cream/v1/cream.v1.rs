// @generated
// This file is @generated by prost-build.
// ============================================
// Common Messages
// ============================================

/// Option contract details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionContract {
    /// Underlying symbol (e.g., "AAPL")
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Expiration date in YYYY-MM-DD format
    #[prost(string, tag="2")]
    pub expiration: ::prost::alloc::string::String,
    /// Strike price
    #[prost(double, tag="3")]
    pub strike: f64,
    /// Call or put
    #[prost(enumeration="OptionType", tag="4")]
    pub option_type: i32,
}
/// Instrument identifier
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instrument {
    /// Unique identifier (ticker or OCC symbol for options)
    #[prost(string, tag="1")]
    pub instrument_id: ::prost::alloc::string::String,
    /// Type of instrument
    #[prost(enumeration="InstrumentType", tag="2")]
    pub instrument_type: i32,
    /// Option contract details (required when instrument_type is OPTION)
    #[prost(message, optional, tag="3")]
    pub option_contract: ::core::option::Option<OptionContract>,
}
/// Position sizing
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Size {
    /// Number of shares or contracts
    #[prost(int32, tag="1")]
    pub quantity: i32,
    /// Unit of size
    #[prost(enumeration="SizeUnit", tag="2")]
    pub unit: i32,
    /// Target position after execution (signed: positive=long, negative=short)
    #[prost(int32, tag="3")]
    pub target_position_quantity: i32,
}
/// Risk levels - mandatory for all decisions
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RiskLevels {
    /// Stop-loss price level
    #[prost(double, tag="1")]
    pub stop_loss_level: f64,
    /// Take-profit price level
    #[prost(double, tag="2")]
    pub take_profit_level: f64,
    /// What price the levels refer to
    #[prost(enumeration="RiskDenomination", tag="3")]
    pub denomination: i32,
}
// ============================================
// Environment
// ============================================

/// Trading environment
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Environment {
    Unspecified = 0,
    Backtest = 1,
    Paper = 2,
    Live = 3,
}
impl Environment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENVIRONMENT_UNSPECIFIED",
            Self::Backtest => "ENVIRONMENT_BACKTEST",
            Self::Paper => "ENVIRONMENT_PAPER",
            Self::Live => "ENVIRONMENT_LIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENVIRONMENT_UNSPECIFIED" => Some(Self::Unspecified),
            "ENVIRONMENT_BACKTEST" => Some(Self::Backtest),
            "ENVIRONMENT_PAPER" => Some(Self::Paper),
            "ENVIRONMENT_LIVE" => Some(Self::Live),
            _ => None,
        }
    }
}
// ============================================
// Trading Enums
// ============================================

/// Trading action that expresses intent in terms of exposure
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Unspecified = 0,
    /// Establish new long from flat
    Buy = 1,
    /// Establish new short from flat
    Sell = 2,
    /// Maintain current position
    Hold = 3,
    /// Increase exposure in direction
    Increase = 4,
    /// Reduce exposure magnitude
    Reduce = 5,
    /// Remain flat
    NoTrade = 6,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTION_UNSPECIFIED",
            Self::Buy => "ACTION_BUY",
            Self::Sell => "ACTION_SELL",
            Self::Hold => "ACTION_HOLD",
            Self::Increase => "ACTION_INCREASE",
            Self::Reduce => "ACTION_REDUCE",
            Self::NoTrade => "ACTION_NO_TRADE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_BUY" => Some(Self::Buy),
            "ACTION_SELL" => Some(Self::Sell),
            "ACTION_HOLD" => Some(Self::Hold),
            "ACTION_INCREASE" => Some(Self::Increase),
            "ACTION_REDUCE" => Some(Self::Reduce),
            "ACTION_NO_TRADE" => Some(Self::NoTrade),
            _ => None,
        }
    }
}
/// Direction derived from action and position
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Unspecified = 0,
    Long = 1,
    Short = 2,
    Flat = 3,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIRECTION_UNSPECIFIED",
            Self::Long => "DIRECTION_LONG",
            Self::Short => "DIRECTION_SHORT",
            Self::Flat => "DIRECTION_FLAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "DIRECTION_LONG" => Some(Self::Long),
            "DIRECTION_SHORT" => Some(Self::Short),
            "DIRECTION_FLAT" => Some(Self::Flat),
            _ => None,
        }
    }
}
/// Instrument type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentType {
    Unspecified = 0,
    Equity = 1,
    Option = 2,
}
impl InstrumentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INSTRUMENT_TYPE_UNSPECIFIED",
            Self::Equity => "INSTRUMENT_TYPE_EQUITY",
            Self::Option => "INSTRUMENT_TYPE_OPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTRUMENT_TYPE_EQUITY" => Some(Self::Equity),
            "INSTRUMENT_TYPE_OPTION" => Some(Self::Option),
            _ => None,
        }
    }
}
/// Option type (call or put)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionType {
    Unspecified = 0,
    Call = 1,
    Put = 2,
}
impl OptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPTION_TYPE_UNSPECIFIED",
            Self::Call => "OPTION_TYPE_CALL",
            Self::Put => "OPTION_TYPE_PUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPTION_TYPE_CALL" => Some(Self::Call),
            "OPTION_TYPE_PUT" => Some(Self::Put),
            _ => None,
        }
    }
}
/// Size unit for position sizing
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SizeUnit {
    Unspecified = 0,
    Shares = 1,
    Contracts = 2,
}
impl SizeUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIZE_UNIT_UNSPECIFIED",
            Self::Shares => "SIZE_UNIT_SHARES",
            Self::Contracts => "SIZE_UNIT_CONTRACTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIZE_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "SIZE_UNIT_SHARES" => Some(Self::Shares),
            "SIZE_UNIT_CONTRACTS" => Some(Self::Contracts),
            _ => None,
        }
    }
}
/// Order type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Unspecified = 0,
    Limit = 1,
    Market = 2,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_TYPE_UNSPECIFIED",
            Self::Limit => "ORDER_TYPE_LIMIT",
            Self::Market => "ORDER_TYPE_MARKET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_TYPE_LIMIT" => Some(Self::Limit),
            "ORDER_TYPE_MARKET" => Some(Self::Market),
            _ => None,
        }
    }
}
/// Time in force for orders
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeInForce {
    Unspecified = 0,
    Day = 1,
    /// Good 'til canceled
    Gtc = 2,
    /// Immediate or cancel
    Ioc = 3,
    /// Fill or kill
    Fok = 4,
}
impl TimeInForce {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
            Self::Day => "TIME_IN_FORCE_DAY",
            Self::Gtc => "TIME_IN_FORCE_GTC",
            Self::Ioc => "TIME_IN_FORCE_IOC",
            Self::Fok => "TIME_IN_FORCE_FOK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
            "TIME_IN_FORCE_DAY" => Some(Self::Day),
            "TIME_IN_FORCE_GTC" => Some(Self::Gtc),
            "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
            "TIME_IN_FORCE_FOK" => Some(Self::Fok),
            _ => None,
        }
    }
}
/// Risk level denomination
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RiskDenomination {
    Unspecified = 0,
    UnderlyingPrice = 1,
    OptionPrice = 2,
}
impl RiskDenomination {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RISK_DENOMINATION_UNSPECIFIED",
            Self::UnderlyingPrice => "RISK_DENOMINATION_UNDERLYING_PRICE",
            Self::OptionPrice => "RISK_DENOMINATION_OPTION_PRICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RISK_DENOMINATION_UNSPECIFIED" => Some(Self::Unspecified),
            "RISK_DENOMINATION_UNDERLYING_PRICE" => Some(Self::UnderlyingPrice),
            "RISK_DENOMINATION_OPTION_PRICE" => Some(Self::OptionPrice),
            _ => None,
        }
    }
}
/// Strategy family
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StrategyFamily {
    Unspecified = 0,
    Trend = 1,
    MeanReversion = 2,
    EventDriven = 3,
    Volatility = 4,
    RelativeValue = 5,
}
impl StrategyFamily {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STRATEGY_FAMILY_UNSPECIFIED",
            Self::Trend => "STRATEGY_FAMILY_TREND",
            Self::MeanReversion => "STRATEGY_FAMILY_MEAN_REVERSION",
            Self::EventDriven => "STRATEGY_FAMILY_EVENT_DRIVEN",
            Self::Volatility => "STRATEGY_FAMILY_VOLATILITY",
            Self::RelativeValue => "STRATEGY_FAMILY_RELATIVE_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STRATEGY_FAMILY_UNSPECIFIED" => Some(Self::Unspecified),
            "STRATEGY_FAMILY_TREND" => Some(Self::Trend),
            "STRATEGY_FAMILY_MEAN_REVERSION" => Some(Self::MeanReversion),
            "STRATEGY_FAMILY_EVENT_DRIVEN" => Some(Self::EventDriven),
            "STRATEGY_FAMILY_VOLATILITY" => Some(Self::Volatility),
            "STRATEGY_FAMILY_RELATIVE_VALUE" => Some(Self::RelativeValue),
            _ => None,
        }
    }
}
/// Regime classification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Regime {
    Unspecified = 0,
    BullTrend = 1,
    BearTrend = 2,
    RangeBound = 3,
    HighVolatility = 4,
    LowVolatility = 5,
    Crisis = 6,
}
impl Regime {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REGIME_UNSPECIFIED",
            Self::BullTrend => "REGIME_BULL_TREND",
            Self::BearTrend => "REGIME_BEAR_TREND",
            Self::RangeBound => "REGIME_RANGE_BOUND",
            Self::HighVolatility => "REGIME_HIGH_VOLATILITY",
            Self::LowVolatility => "REGIME_LOW_VOLATILITY",
            Self::Crisis => "REGIME_CRISIS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGIME_UNSPECIFIED" => Some(Self::Unspecified),
            "REGIME_BULL_TREND" => Some(Self::BullTrend),
            "REGIME_BEAR_TREND" => Some(Self::BearTrend),
            "REGIME_RANGE_BOUND" => Some(Self::RangeBound),
            "REGIME_HIGH_VOLATILITY" => Some(Self::HighVolatility),
            "REGIME_LOW_VOLATILITY" => Some(Self::LowVolatility),
            "REGIME_CRISIS" => Some(Self::Crisis),
            _ => None,
        }
    }
}
/// Market hours status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MarketStatus {
    Unspecified = 0,
    PreMarket = 1,
    Open = 2,
    AfterHours = 3,
    Closed = 4,
}
impl MarketStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MARKET_STATUS_UNSPECIFIED",
            Self::PreMarket => "MARKET_STATUS_PRE_MARKET",
            Self::Open => "MARKET_STATUS_OPEN",
            Self::AfterHours => "MARKET_STATUS_AFTER_HOURS",
            Self::Closed => "MARKET_STATUS_CLOSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MARKET_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "MARKET_STATUS_PRE_MARKET" => Some(Self::PreMarket),
            "MARKET_STATUS_OPEN" => Some(Self::Open),
            "MARKET_STATUS_AFTER_HOURS" => Some(Self::AfterHours),
            "MARKET_STATUS_CLOSED" => Some(Self::Closed),
            _ => None,
        }
    }
}
// ============================================
// Order Planning
// ============================================

/// Order execution plan
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderPlan {
    /// Order type for entry
    #[prost(enumeration="OrderType", tag="1")]
    pub entry_order_type: i32,
    /// Limit price for entry (required when entry_order_type is LIMIT)
    #[prost(double, optional, tag="2")]
    pub entry_limit_price: ::core::option::Option<f64>,
    /// Order type for exit
    #[prost(enumeration="OrderType", tag="3")]
    pub exit_order_type: i32,
    /// Time in force for orders
    #[prost(enumeration="TimeInForce", tag="4")]
    pub time_in_force: i32,
    /// Execution tactic identifier (e.g., "TWAP", "VWAP", "ICEBERG")
    #[prost(string, optional, tag="5")]
    pub execution_tactic: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional execution parameters
    #[prost(message, optional, tag="6")]
    pub execution_params: ::core::option::Option<super::super::google::protobuf::Struct>,
}
// ============================================
// References
// ============================================

/// References to supporting data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct References {
    /// Indicator names used in decision
    #[prost(string, repeated, tag="1")]
    pub used_indicators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Memory case IDs from HelixDB
    #[prost(string, repeated, tag="2")]
    pub memory_case_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Event IDs that influenced decision
    #[prost(string, repeated, tag="3")]
    pub event_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
// ============================================
// Decision
// ============================================

/// Individual decision for an instrument
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decision {
    /// Target instrument
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Trading action
    #[prost(enumeration="Action", tag="2")]
    pub action: i32,
    /// Position sizing
    #[prost(message, optional, tag="3")]
    pub size: ::core::option::Option<Size>,
    /// Order execution plan
    #[prost(message, optional, tag="4")]
    pub order_plan: ::core::option::Option<OrderPlan>,
    /// Risk levels (mandatory - always required)
    #[prost(message, optional, tag="5")]
    pub risk_levels: ::core::option::Option<RiskLevels>,
    /// Strategy family
    #[prost(enumeration="StrategyFamily", tag="6")]
    pub strategy_family: i32,
    /// Human-readable rationale for the decision
    #[prost(string, tag="7")]
    pub rationale: ::prost::alloc::string::String,
    /// Confidence score \[0.0, 1.0\]
    #[prost(double, tag="8")]
    pub confidence: f64,
    /// Supporting references
    #[prost(message, optional, tag="9")]
    pub references: ::core::option::Option<References>,
}
// ============================================
// DecisionPlan
// ============================================

/// Complete decision plan for a trading cycle
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionPlan {
    /// Unique identifier for this trading cycle
    #[prost(string, tag="1")]
    pub cycle_id: ::prost::alloc::string::String,
    /// Timestamp when the decision was made
    #[prost(message, optional, tag="2")]
    pub as_of_timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Trading environment
    #[prost(enumeration="Environment", tag="3")]
    pub environment: i32,
    /// List of decisions for this cycle
    #[prost(message, repeated, tag="4")]
    pub decisions: ::prost::alloc::vec::Vec<Decision>,
    /// Optional portfolio-level notes
    #[prost(string, optional, tag="5")]
    pub portfolio_notes: ::core::option::Option<::prost::alloc::string::String>,
}
// ============================================
// Validation
// ============================================

/// Risk validation result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskValidationResult {
    /// Whether the validation passed
    #[prost(bool, tag="1")]
    pub valid: bool,
    /// Validation errors (blocking issues)
    #[prost(string, repeated, tag="2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Validation warnings (non-blocking issues)
    #[prost(string, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Calculated risk-reward ratio
    #[prost(double, optional, tag="4")]
    pub risk_reward_ratio: ::core::option::Option<f64>,
}
/// Decision plan validation result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionPlanValidationResult {
    /// Whether the validation passed
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Validated decision plan (if successful)
    #[prost(message, optional, tag="2")]
    pub decision_plan: ::core::option::Option<DecisionPlan>,
    /// Validation errors
    #[prost(string, repeated, tag="3")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Validation warnings
    #[prost(string, repeated, tag="4")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Individual constraint check result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstraintCheck {
    /// Name of the constraint
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Result of the check
    #[prost(enumeration="ConstraintResult", tag="2")]
    pub result: i32,
    /// Description of the constraint
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Actual value that was checked
    #[prost(double, optional, tag="4")]
    pub actual_value: ::core::option::Option<f64>,
    /// Threshold that was applied
    #[prost(double, optional, tag="5")]
    pub threshold: ::core::option::Option<f64>,
}
/// Request to validate a decision plan against constraints
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckConstraintsRequest {
    /// Decision plan to validate
    #[prost(message, optional, tag="1")]
    pub decision_plan: ::core::option::Option<DecisionPlan>,
    /// Current account state
    #[prost(message, optional, tag="2")]
    pub account_state: ::core::option::Option<AccountState>,
    /// Current positions
    #[prost(message, repeated, tag="3")]
    pub positions: ::prost::alloc::vec::Vec<Position>,
}
/// Response from constraint validation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckConstraintsResponse {
    /// Overall result
    #[prost(bool, tag="1")]
    pub approved: bool,
    /// Individual constraint results
    #[prost(message, repeated, tag="2")]
    pub checks: ::prost::alloc::vec::Vec<ConstraintCheck>,
    /// Timestamp of validation
    #[prost(message, optional, tag="3")]
    pub validated_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Rejection reason (if not approved)
    #[prost(string, optional, tag="4")]
    pub rejection_reason: ::core::option::Option<::prost::alloc::string::String>,
}
// ============================================
// Account State
// ============================================

/// Current account state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountState {
    /// Account identifier
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    /// Total account equity
    #[prost(double, tag="2")]
    pub equity: f64,
    /// Available cash for trading
    #[prost(double, tag="3")]
    pub buying_power: f64,
    /// Current margin used
    #[prost(double, tag="4")]
    pub margin_used: f64,
    /// Day trade count (for PDT rule)
    #[prost(int32, tag="5")]
    pub day_trade_count: i32,
    /// Whether pattern day trader rules apply
    #[prost(bool, tag="6")]
    pub is_pdt_restricted: bool,
    /// Timestamp of state snapshot
    #[prost(message, optional, tag="7")]
    pub as_of: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
// ============================================
// Positions
// ============================================

/// Current position
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    /// Instrument
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Quantity held (signed: positive=long, negative=short)
    #[prost(int32, tag="2")]
    pub quantity: i32,
    /// Average entry price
    #[prost(double, tag="3")]
    pub avg_entry_price: f64,
    /// Current market value
    #[prost(double, tag="4")]
    pub market_value: f64,
    /// Unrealized P&L
    #[prost(double, tag="5")]
    pub unrealized_pnl: f64,
    /// Unrealized P&L percentage
    #[prost(double, tag="6")]
    pub unrealized_pnl_pct: f64,
    /// Cost basis
    #[prost(double, tag="7")]
    pub cost_basis: f64,
}
/// Request to submit an order
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOrderRequest {
    /// Instrument to trade
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Buy or sell
    #[prost(enumeration="OrderSide", tag="2")]
    pub side: i32,
    /// Quantity
    #[prost(int32, tag="3")]
    pub quantity: i32,
    /// Order type
    #[prost(enumeration="OrderType", tag="4")]
    pub order_type: i32,
    /// Limit price (required for limit orders)
    #[prost(double, optional, tag="5")]
    pub limit_price: ::core::option::Option<f64>,
    /// Time in force
    #[prost(enumeration="TimeInForce", tag="6")]
    pub time_in_force: i32,
    /// Client order ID for tracking
    #[prost(string, tag="7")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Reference to decision cycle
    #[prost(string, tag="8")]
    pub cycle_id: ::prost::alloc::string::String,
}
/// Response from order submission
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitOrderResponse {
    /// Broker-assigned order ID
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
    /// Client order ID (echoed back)
    #[prost(string, tag="2")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Current order status
    #[prost(enumeration="OrderStatus", tag="3")]
    pub status: i32,
    /// Submission timestamp
    #[prost(message, optional, tag="4")]
    pub submitted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Error message if rejected
    #[prost(string, optional, tag="5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Order execution acknowledgment
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionAck {
    /// Order ID
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
    /// Client order ID
    #[prost(string, tag="2")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Current status
    #[prost(enumeration="OrderStatus", tag="3")]
    pub status: i32,
    /// Filled quantity
    #[prost(int32, tag="4")]
    pub filled_quantity: i32,
    /// Average fill price
    #[prost(double, tag="5")]
    pub avg_fill_price: f64,
    /// Remaining quantity
    #[prost(int32, tag="6")]
    pub remaining_quantity: i32,
    /// Last update timestamp
    #[prost(message, optional, tag="7")]
    pub updated_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Commission charged
    #[prost(double, tag="8")]
    pub commission: f64,
}
/// Request to stream executions
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamExecutionsRequest {
    /// Filter by cycle ID (optional)
    #[prost(string, optional, tag="1")]
    pub cycle_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by order IDs (optional)
    #[prost(string, repeated, tag="2")]
    pub order_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response with execution update (streamed)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamExecutionsResponse {
    /// Execution acknowledgment
    #[prost(message, optional, tag="1")]
    pub execution: ::core::option::Option<ExecutionAck>,
}
/// Request for account state
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAccountStateRequest {
    /// Account ID (uses default if not specified)
    #[prost(string, optional, tag="1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response with account state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountStateResponse {
    /// Current account state
    #[prost(message, optional, tag="1")]
    pub account_state: ::core::option::Option<AccountState>,
}
/// Request for positions
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPositionsRequest {
    /// Account ID (uses default if not specified)
    #[prost(string, optional, tag="1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by symbols (optional)
    #[prost(string, repeated, tag="2")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response with positions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPositionsResponse {
    /// Current positions
    #[prost(message, repeated, tag="1")]
    pub positions: ::prost::alloc::vec::Vec<Position>,
    /// Timestamp of snapshot
    #[prost(message, optional, tag="2")]
    pub as_of: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
// ============================================
// Constraint Check
// ============================================

/// Result of a constraint check
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConstraintResult {
    Unspecified = 0,
    Pass = 1,
    Fail = 2,
    Warn = 3,
}
impl ConstraintResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSTRAINT_RESULT_UNSPECIFIED",
            Self::Pass => "CONSTRAINT_RESULT_PASS",
            Self::Fail => "CONSTRAINT_RESULT_FAIL",
            Self::Warn => "CONSTRAINT_RESULT_WARN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSTRAINT_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSTRAINT_RESULT_PASS" => Some(Self::Pass),
            "CONSTRAINT_RESULT_FAIL" => Some(Self::Fail),
            "CONSTRAINT_RESULT_WARN" => Some(Self::Warn),
            _ => None,
        }
    }
}
// ============================================
// Order Execution
// ============================================

/// Order status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderStatus {
    Unspecified = 0,
    Pending = 1,
    Accepted = 2,
    PartialFill = 3,
    Filled = 4,
    Cancelled = 5,
    Rejected = 6,
    Expired = 7,
}
impl OrderStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_STATUS_UNSPECIFIED",
            Self::Pending => "ORDER_STATUS_PENDING",
            Self::Accepted => "ORDER_STATUS_ACCEPTED",
            Self::PartialFill => "ORDER_STATUS_PARTIAL_FILL",
            Self::Filled => "ORDER_STATUS_FILLED",
            Self::Cancelled => "ORDER_STATUS_CANCELLED",
            Self::Rejected => "ORDER_STATUS_REJECTED",
            Self::Expired => "ORDER_STATUS_EXPIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_STATUS_PENDING" => Some(Self::Pending),
            "ORDER_STATUS_ACCEPTED" => Some(Self::Accepted),
            "ORDER_STATUS_PARTIAL_FILL" => Some(Self::PartialFill),
            "ORDER_STATUS_FILLED" => Some(Self::Filled),
            "ORDER_STATUS_CANCELLED" => Some(Self::Cancelled),
            "ORDER_STATUS_REJECTED" => Some(Self::Rejected),
            "ORDER_STATUS_EXPIRED" => Some(Self::Expired),
            _ => None,
        }
    }
}
/// Order side
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderSide {
    Unspecified = 0,
    Buy = 1,
    Sell = 2,
}
impl OrderSide {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_SIDE_UNSPECIFIED",
            Self::Buy => "ORDER_SIDE_BUY",
            Self::Sell => "ORDER_SIDE_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_SIDE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_SIDE_BUY" => Some(Self::Buy),
            "ORDER_SIDE_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
// ============================================
// Quote Data
// ============================================

/// Real-time quote for a symbol
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quote {
    /// Symbol (e.g., "AAPL")
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Best bid price
    #[prost(double, tag="2")]
    pub bid: f64,
    /// Best ask price
    #[prost(double, tag="3")]
    pub ask: f64,
    /// Bid size (shares/contracts)
    #[prost(int32, tag="4")]
    pub bid_size: i32,
    /// Ask size (shares/contracts)
    #[prost(int32, tag="5")]
    pub ask_size: i32,
    /// Last trade price
    #[prost(double, tag="6")]
    pub last: f64,
    /// Last trade size
    #[prost(int32, tag="7")]
    pub last_size: i32,
    /// Cumulative volume
    #[prost(int64, tag="8")]
    pub volume: i64,
    /// Quote timestamp
    #[prost(message, optional, tag="9")]
    pub timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
// ============================================
// OHLCV Bar
// ============================================

/// OHLCV candlestick bar
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bar {
    /// Symbol
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Bar open time
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Bar timeframe in minutes (1, 5, 15, 60, 240, 1440)
    #[prost(int32, tag="3")]
    pub timeframe_minutes: i32,
    /// Open price
    #[prost(double, tag="4")]
    pub open: f64,
    /// High price
    #[prost(double, tag="5")]
    pub high: f64,
    /// Low price
    #[prost(double, tag="6")]
    pub low: f64,
    /// Close price
    #[prost(double, tag="7")]
    pub close: f64,
    /// Volume
    #[prost(int64, tag="8")]
    pub volume: i64,
    /// VWAP (volume-weighted average price)
    #[prost(double, optional, tag="9")]
    pub vwap: ::core::option::Option<f64>,
    /// Number of trades
    #[prost(int32, optional, tag="10")]
    pub trade_count: ::core::option::Option<i32>,
}
// ============================================
// Market Snapshot
// ============================================

/// Complete market snapshot for a symbol
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolSnapshot {
    /// Symbol
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Current quote
    #[prost(message, optional, tag="2")]
    pub quote: ::core::option::Option<Quote>,
    /// Latest completed bars (multiple timeframes)
    #[prost(message, repeated, tag="3")]
    pub bars: ::prost::alloc::vec::Vec<Bar>,
    /// Market status
    #[prost(enumeration="MarketStatus", tag="4")]
    pub market_status: i32,
    /// Daily high
    #[prost(double, tag="5")]
    pub day_high: f64,
    /// Daily low
    #[prost(double, tag="6")]
    pub day_low: f64,
    /// Previous close
    #[prost(double, tag="7")]
    pub prev_close: f64,
    /// Today's open
    #[prost(double, tag="8")]
    pub open: f64,
    /// Snapshot timestamp
    #[prost(message, optional, tag="9")]
    pub as_of: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// Full market snapshot for multiple symbols
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketSnapshot {
    /// Trading environment
    #[prost(enumeration="Environment", tag="1")]
    pub environment: i32,
    /// Snapshot timestamp
    #[prost(message, optional, tag="2")]
    pub as_of: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Market status (overall)
    #[prost(enumeration="MarketStatus", tag="3")]
    pub market_status: i32,
    /// Current regime classification
    #[prost(enumeration="Regime", tag="4")]
    pub regime: i32,
    /// Symbol snapshots
    #[prost(message, repeated, tag="5")]
    pub symbols: ::prost::alloc::vec::Vec<SymbolSnapshot>,
}
// ============================================
// Option Chain
// ============================================

/// Option quote
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionQuote {
    /// Option contract
    #[prost(message, optional, tag="1")]
    pub contract: ::core::option::Option<OptionContract>,
    /// Quote data
    #[prost(message, optional, tag="2")]
    pub quote: ::core::option::Option<Quote>,
    /// Implied volatility
    #[prost(double, optional, tag="3")]
    pub implied_volatility: ::core::option::Option<f64>,
    /// Delta
    #[prost(double, optional, tag="4")]
    pub delta: ::core::option::Option<f64>,
    /// Gamma
    #[prost(double, optional, tag="5")]
    pub gamma: ::core::option::Option<f64>,
    /// Theta
    #[prost(double, optional, tag="6")]
    pub theta: ::core::option::Option<f64>,
    /// Vega
    #[prost(double, optional, tag="7")]
    pub vega: ::core::option::Option<f64>,
    /// Rho
    #[prost(double, optional, tag="8")]
    pub rho: ::core::option::Option<f64>,
    /// Open interest
    #[prost(int32, tag="9")]
    pub open_interest: i32,
}
/// Option chain for an underlying
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionChain {
    /// Underlying symbol
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Underlying price
    #[prost(double, tag="2")]
    pub underlying_price: f64,
    /// Option quotes
    #[prost(message, repeated, tag="3")]
    pub options: ::prost::alloc::vec::Vec<OptionQuote>,
    /// Chain timestamp
    #[prost(message, optional, tag="4")]
    pub as_of: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
// ============================================
// Streaming Service
// ============================================

/// Request to subscribe to market data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeMarketDataRequest {
    /// Symbols to subscribe to
    #[prost(string, repeated, tag="1")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Include option chains
    #[prost(bool, tag="2")]
    pub include_options: bool,
    /// Bar timeframes to include (in minutes)
    #[prost(int32, repeated, tag="3")]
    pub bar_timeframes: ::prost::alloc::vec::Vec<i32>,
}
/// Market data update (streamed response)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeMarketDataResponse {
    /// Update type
    #[prost(oneof="subscribe_market_data_response::Update", tags="1, 2, 3, 4")]
    pub update: ::core::option::Option<subscribe_market_data_response::Update>,
}
/// Nested message and enum types in `SubscribeMarketDataResponse`.
pub mod subscribe_market_data_response {
    /// Update type
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag="1")]
        Quote(super::Quote),
        #[prost(message, tag="2")]
        Bar(super::Bar),
        #[prost(message, tag="3")]
        OptionQuote(super::OptionQuote),
        #[prost(message, tag="4")]
        Snapshot(super::SymbolSnapshot),
    }
}
/// Request for snapshot
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSnapshotRequest {
    /// Symbols to get snapshot for
    #[prost(string, repeated, tag="1")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Include bars
    #[prost(bool, tag="2")]
    pub include_bars: bool,
    /// Bar timeframes to include
    #[prost(int32, repeated, tag="3")]
    pub bar_timeframes: ::prost::alloc::vec::Vec<i32>,
}
/// Response with snapshot
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnapshotResponse {
    /// Market snapshot
    #[prost(message, optional, tag="1")]
    pub snapshot: ::core::option::Option<MarketSnapshot>,
}
/// Request for option chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOptionChainRequest {
    /// Underlying symbol
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Expiration dates to include (YYYY-MM-DD format, empty for all)
    #[prost(string, repeated, tag="2")]
    pub expirations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Strike range (min)
    #[prost(double, optional, tag="3")]
    pub min_strike: ::core::option::Option<f64>,
    /// Strike range (max)
    #[prost(double, optional, tag="4")]
    pub max_strike: ::core::option::Option<f64>,
}
/// Response with option chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOptionChainResponse {
    /// Option chain
    #[prost(message, optional, tag="1")]
    pub chain: ::core::option::Option<OptionChain>,
}
include!("cream.v1.serde.rs");
// @@protoc_insertion_point(module)