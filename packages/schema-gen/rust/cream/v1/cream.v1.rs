// @generated
// This file is @generated by prost-build.
// ============================================
// Common Messages
// ============================================

/// Option contract details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionContract {
    /// Underlying symbol (e.g., "AAPL")
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Expiration date in YYYY-MM-DD format
    #[prost(string, tag="2")]
    pub expiration: ::prost::alloc::string::String,
    /// Strike price
    #[prost(double, tag="3")]
    pub strike: f64,
    /// Call or put
    #[prost(enumeration="OptionType", tag="4")]
    pub option_type: i32,
}
/// Instrument identifier
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instrument {
    /// Unique identifier (ticker or OCC symbol for options)
    #[prost(string, tag="1")]
    pub instrument_id: ::prost::alloc::string::String,
    /// Type of instrument
    #[prost(enumeration="InstrumentType", tag="2")]
    pub instrument_type: i32,
    /// Option contract details (required when instrument_type is OPTION)
    #[prost(message, optional, tag="3")]
    pub option_contract: ::core::option::Option<OptionContract>,
}
/// Position sizing
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Size {
    /// Number of shares or contracts
    #[prost(int32, tag="1")]
    pub quantity: i32,
    /// Unit of size
    #[prost(enumeration="SizeUnit", tag="2")]
    pub unit: i32,
    /// Target position after execution (signed: positive=long, negative=short)
    #[prost(int32, tag="3")]
    pub target_position_quantity: i32,
}
/// Risk levels - mandatory for all decisions
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RiskLevels {
    /// Stop-loss price level
    #[prost(double, tag="1")]
    pub stop_loss_level: f64,
    /// Take-profit price level
    #[prost(double, tag="2")]
    pub take_profit_level: f64,
    /// What price the levels refer to
    #[prost(enumeration="RiskDenomination", tag="3")]
    pub denomination: i32,
}
/// Option leg for multi-leg strategies
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionLeg {
    /// OCC option symbol (e.g., "AAPL250117P00190000")
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Quantity ratio - positive for buy, negative for sell
    #[prost(int32, tag="2")]
    pub ratio_qty: i32,
    /// Position intent for the leg
    #[prost(enumeration="PositionIntent", tag="3")]
    pub position_intent: i32,
    /// Parsed contract details
    #[prost(message, optional, tag="4")]
    pub contract: ::core::option::Option<OptionContract>,
}
// ============================================
// Environment
// ============================================

/// Trading environment
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Environment {
    Unspecified = 0,
    Paper = 2,
    Live = 3,
}
impl Environment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENVIRONMENT_UNSPECIFIED",
            Self::Paper => "ENVIRONMENT_PAPER",
            Self::Live => "ENVIRONMENT_LIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENVIRONMENT_UNSPECIFIED" => Some(Self::Unspecified),
            "ENVIRONMENT_PAPER" => Some(Self::Paper),
            "ENVIRONMENT_LIVE" => Some(Self::Live),
            _ => None,
        }
    }
}
// ============================================
// Trading Enums
// ============================================

/// Trading action that expresses intent in terms of exposure
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Action {
    Unspecified = 0,
    /// Establish new long from flat
    Buy = 1,
    /// Establish new short from flat
    Sell = 2,
    /// Maintain current position
    Hold = 3,
    /// Increase exposure in direction
    Increase = 4,
    /// Reduce exposure magnitude
    Reduce = 5,
    /// Remain flat
    NoTrade = 6,
    /// Close an existing position
    Close = 7,
}
impl Action {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACTION_UNSPECIFIED",
            Self::Buy => "ACTION_BUY",
            Self::Sell => "ACTION_SELL",
            Self::Hold => "ACTION_HOLD",
            Self::Increase => "ACTION_INCREASE",
            Self::Reduce => "ACTION_REDUCE",
            Self::NoTrade => "ACTION_NO_TRADE",
            Self::Close => "ACTION_CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ACTION_BUY" => Some(Self::Buy),
            "ACTION_SELL" => Some(Self::Sell),
            "ACTION_HOLD" => Some(Self::Hold),
            "ACTION_INCREASE" => Some(Self::Increase),
            "ACTION_REDUCE" => Some(Self::Reduce),
            "ACTION_NO_TRADE" => Some(Self::NoTrade),
            "ACTION_CLOSE" => Some(Self::Close),
            _ => None,
        }
    }
}
/// Direction derived from action and position
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Unspecified = 0,
    Long = 1,
    Short = 2,
    Flat = 3,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIRECTION_UNSPECIFIED",
            Self::Long => "DIRECTION_LONG",
            Self::Short => "DIRECTION_SHORT",
            Self::Flat => "DIRECTION_FLAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "DIRECTION_LONG" => Some(Self::Long),
            "DIRECTION_SHORT" => Some(Self::Short),
            "DIRECTION_FLAT" => Some(Self::Flat),
            _ => None,
        }
    }
}
/// Instrument type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentType {
    Unspecified = 0,
    Equity = 1,
    Option = 2,
}
impl InstrumentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INSTRUMENT_TYPE_UNSPECIFIED",
            Self::Equity => "INSTRUMENT_TYPE_EQUITY",
            Self::Option => "INSTRUMENT_TYPE_OPTION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTRUMENT_TYPE_EQUITY" => Some(Self::Equity),
            "INSTRUMENT_TYPE_OPTION" => Some(Self::Option),
            _ => None,
        }
    }
}
/// Option type (call or put)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OptionType {
    Unspecified = 0,
    Call = 1,
    Put = 2,
}
impl OptionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPTION_TYPE_UNSPECIFIED",
            Self::Call => "OPTION_TYPE_CALL",
            Self::Put => "OPTION_TYPE_PUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPTION_TYPE_CALL" => Some(Self::Call),
            "OPTION_TYPE_PUT" => Some(Self::Put),
            _ => None,
        }
    }
}
/// Size unit for position sizing
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SizeUnit {
    Unspecified = 0,
    Shares = 1,
    Contracts = 2,
    Dollars = 3,
    PctEquity = 4,
}
impl SizeUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIZE_UNIT_UNSPECIFIED",
            Self::Shares => "SIZE_UNIT_SHARES",
            Self::Contracts => "SIZE_UNIT_CONTRACTS",
            Self::Dollars => "SIZE_UNIT_DOLLARS",
            Self::PctEquity => "SIZE_UNIT_PCT_EQUITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIZE_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "SIZE_UNIT_SHARES" => Some(Self::Shares),
            "SIZE_UNIT_CONTRACTS" => Some(Self::Contracts),
            "SIZE_UNIT_DOLLARS" => Some(Self::Dollars),
            "SIZE_UNIT_PCT_EQUITY" => Some(Self::PctEquity),
            _ => None,
        }
    }
}
/// Order type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Unspecified = 0,
    Limit = 1,
    Market = 2,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_TYPE_UNSPECIFIED",
            Self::Limit => "ORDER_TYPE_LIMIT",
            Self::Market => "ORDER_TYPE_MARKET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_TYPE_LIMIT" => Some(Self::Limit),
            "ORDER_TYPE_MARKET" => Some(Self::Market),
            _ => None,
        }
    }
}
/// Time in force for orders
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeInForce {
    Unspecified = 0,
    Day = 1,
    /// Good 'til canceled
    Gtc = 2,
    /// Immediate or cancel
    Ioc = 3,
    /// Fill or kill
    Fok = 4,
    /// Market-on-open
    Opg = 5,
    /// Market-on-close
    Cls = 6,
}
impl TimeInForce {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIME_IN_FORCE_UNSPECIFIED",
            Self::Day => "TIME_IN_FORCE_DAY",
            Self::Gtc => "TIME_IN_FORCE_GTC",
            Self::Ioc => "TIME_IN_FORCE_IOC",
            Self::Fok => "TIME_IN_FORCE_FOK",
            Self::Opg => "TIME_IN_FORCE_OPG",
            Self::Cls => "TIME_IN_FORCE_CLS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIME_IN_FORCE_UNSPECIFIED" => Some(Self::Unspecified),
            "TIME_IN_FORCE_DAY" => Some(Self::Day),
            "TIME_IN_FORCE_GTC" => Some(Self::Gtc),
            "TIME_IN_FORCE_IOC" => Some(Self::Ioc),
            "TIME_IN_FORCE_FOK" => Some(Self::Fok),
            "TIME_IN_FORCE_OPG" => Some(Self::Opg),
            "TIME_IN_FORCE_CLS" => Some(Self::Cls),
            _ => None,
        }
    }
}
/// Risk level denomination
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RiskDenomination {
    Unspecified = 0,
    UnderlyingPrice = 1,
    OptionPrice = 2,
}
impl RiskDenomination {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RISK_DENOMINATION_UNSPECIFIED",
            Self::UnderlyingPrice => "RISK_DENOMINATION_UNDERLYING_PRICE",
            Self::OptionPrice => "RISK_DENOMINATION_OPTION_PRICE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RISK_DENOMINATION_UNSPECIFIED" => Some(Self::Unspecified),
            "RISK_DENOMINATION_UNDERLYING_PRICE" => Some(Self::UnderlyingPrice),
            "RISK_DENOMINATION_OPTION_PRICE" => Some(Self::OptionPrice),
            _ => None,
        }
    }
}
/// Strategy family - position type classification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StrategyFamily {
    Unspecified = 0,
    EquityLong = 1,
    EquityShort = 2,
    OptionLong = 3,
    OptionShort = 4,
    VerticalSpread = 5,
    IronCondor = 6,
    Straddle = 7,
    Strangle = 8,
    CalendarSpread = 9,
}
impl StrategyFamily {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STRATEGY_FAMILY_UNSPECIFIED",
            Self::EquityLong => "STRATEGY_FAMILY_EQUITY_LONG",
            Self::EquityShort => "STRATEGY_FAMILY_EQUITY_SHORT",
            Self::OptionLong => "STRATEGY_FAMILY_OPTION_LONG",
            Self::OptionShort => "STRATEGY_FAMILY_OPTION_SHORT",
            Self::VerticalSpread => "STRATEGY_FAMILY_VERTICAL_SPREAD",
            Self::IronCondor => "STRATEGY_FAMILY_IRON_CONDOR",
            Self::Straddle => "STRATEGY_FAMILY_STRADDLE",
            Self::Strangle => "STRATEGY_FAMILY_STRANGLE",
            Self::CalendarSpread => "STRATEGY_FAMILY_CALENDAR_SPREAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STRATEGY_FAMILY_UNSPECIFIED" => Some(Self::Unspecified),
            "STRATEGY_FAMILY_EQUITY_LONG" => Some(Self::EquityLong),
            "STRATEGY_FAMILY_EQUITY_SHORT" => Some(Self::EquityShort),
            "STRATEGY_FAMILY_OPTION_LONG" => Some(Self::OptionLong),
            "STRATEGY_FAMILY_OPTION_SHORT" => Some(Self::OptionShort),
            "STRATEGY_FAMILY_VERTICAL_SPREAD" => Some(Self::VerticalSpread),
            "STRATEGY_FAMILY_IRON_CONDOR" => Some(Self::IronCondor),
            "STRATEGY_FAMILY_STRADDLE" => Some(Self::Straddle),
            "STRATEGY_FAMILY_STRANGLE" => Some(Self::Strangle),
            "STRATEGY_FAMILY_CALENDAR_SPREAD" => Some(Self::CalendarSpread),
            _ => None,
        }
    }
}
/// Time horizon for the trade
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeHorizon {
    Unspecified = 0,
    Intraday = 1,
    Swing = 2,
    Position = 3,
}
impl TimeHorizon {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TIME_HORIZON_UNSPECIFIED",
            Self::Intraday => "TIME_HORIZON_INTRADAY",
            Self::Swing => "TIME_HORIZON_SWING",
            Self::Position => "TIME_HORIZON_POSITION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIME_HORIZON_UNSPECIFIED" => Some(Self::Unspecified),
            "TIME_HORIZON_INTRADAY" => Some(Self::Intraday),
            "TIME_HORIZON_SWING" => Some(Self::Swing),
            "TIME_HORIZON_POSITION" => Some(Self::Position),
            _ => None,
        }
    }
}
/// Thesis lifecycle state
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThesisState {
    Unspecified = 0,
    Watching = 1,
    Entered = 2,
    Adding = 3,
    Managing = 4,
    Exiting = 5,
    Closed = 6,
}
impl ThesisState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "THESIS_STATE_UNSPECIFIED",
            Self::Watching => "THESIS_STATE_WATCHING",
            Self::Entered => "THESIS_STATE_ENTERED",
            Self::Adding => "THESIS_STATE_ADDING",
            Self::Managing => "THESIS_STATE_MANAGING",
            Self::Exiting => "THESIS_STATE_EXITING",
            Self::Closed => "THESIS_STATE_CLOSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THESIS_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "THESIS_STATE_WATCHING" => Some(Self::Watching),
            "THESIS_STATE_ENTERED" => Some(Self::Entered),
            "THESIS_STATE_ADDING" => Some(Self::Adding),
            "THESIS_STATE_MANAGING" => Some(Self::Managing),
            "THESIS_STATE_EXITING" => Some(Self::Exiting),
            "THESIS_STATE_CLOSED" => Some(Self::Closed),
            _ => None,
        }
    }
}
/// Regime classification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Regime {
    Unspecified = 0,
    BullTrend = 1,
    BearTrend = 2,
    RangeBound = 3,
    HighVolatility = 4,
    LowVolatility = 5,
    Crisis = 6,
}
impl Regime {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REGIME_UNSPECIFIED",
            Self::BullTrend => "REGIME_BULL_TREND",
            Self::BearTrend => "REGIME_BEAR_TREND",
            Self::RangeBound => "REGIME_RANGE_BOUND",
            Self::HighVolatility => "REGIME_HIGH_VOLATILITY",
            Self::LowVolatility => "REGIME_LOW_VOLATILITY",
            Self::Crisis => "REGIME_CRISIS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGIME_UNSPECIFIED" => Some(Self::Unspecified),
            "REGIME_BULL_TREND" => Some(Self::BullTrend),
            "REGIME_BEAR_TREND" => Some(Self::BearTrend),
            "REGIME_RANGE_BOUND" => Some(Self::RangeBound),
            "REGIME_HIGH_VOLATILITY" => Some(Self::HighVolatility),
            "REGIME_LOW_VOLATILITY" => Some(Self::LowVolatility),
            "REGIME_CRISIS" => Some(Self::Crisis),
            _ => None,
        }
    }
}
/// Market hours status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MarketStatus {
    Unspecified = 0,
    PreMarket = 1,
    Open = 2,
    AfterHours = 3,
    Closed = 4,
}
impl MarketStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MARKET_STATUS_UNSPECIFIED",
            Self::PreMarket => "MARKET_STATUS_PRE_MARKET",
            Self::Open => "MARKET_STATUS_OPEN",
            Self::AfterHours => "MARKET_STATUS_AFTER_HOURS",
            Self::Closed => "MARKET_STATUS_CLOSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MARKET_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "MARKET_STATUS_PRE_MARKET" => Some(Self::PreMarket),
            "MARKET_STATUS_OPEN" => Some(Self::Open),
            "MARKET_STATUS_AFTER_HOURS" => Some(Self::AfterHours),
            "MARKET_STATUS_CLOSED" => Some(Self::Closed),
            _ => None,
        }
    }
}
/// Position intent for options orders
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PositionIntent {
    Unspecified = 0,
    BuyToOpen = 1,
    BuyToClose = 2,
    SellToOpen = 3,
    SellToClose = 4,
}
impl PositionIntent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "POSITION_INTENT_UNSPECIFIED",
            Self::BuyToOpen => "POSITION_INTENT_BUY_TO_OPEN",
            Self::BuyToClose => "POSITION_INTENT_BUY_TO_CLOSE",
            Self::SellToOpen => "POSITION_INTENT_SELL_TO_OPEN",
            Self::SellToClose => "POSITION_INTENT_SELL_TO_CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "POSITION_INTENT_UNSPECIFIED" => Some(Self::Unspecified),
            "POSITION_INTENT_BUY_TO_OPEN" => Some(Self::BuyToOpen),
            "POSITION_INTENT_BUY_TO_CLOSE" => Some(Self::BuyToClose),
            "POSITION_INTENT_SELL_TO_OPEN" => Some(Self::SellToOpen),
            "POSITION_INTENT_SELL_TO_CLOSE" => Some(Self::SellToClose),
            _ => None,
        }
    }
}
// ============================================
// Order Planning
// ============================================

/// Order execution plan
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderPlan {
    /// Order type for entry
    #[prost(enumeration="OrderType", tag="1")]
    pub entry_order_type: i32,
    /// Limit price for entry (required when entry_order_type is LIMIT)
    #[prost(double, optional, tag="2")]
    pub entry_limit_price: ::core::option::Option<f64>,
    /// Order type for exit
    #[prost(enumeration="OrderType", tag="3")]
    pub exit_order_type: i32,
    /// Time in force for orders
    #[prost(enumeration="TimeInForce", tag="4")]
    pub time_in_force: i32,
    /// Execution tactic identifier (e.g., "TWAP", "VWAP", "ICEBERG")
    #[prost(string, optional, tag="5")]
    pub execution_tactic: ::core::option::Option<::prost::alloc::string::String>,
    /// Additional execution parameters
    #[prost(message, optional, tag="6")]
    pub execution_params: ::core::option::Option<::prost_types::Struct>,
}
// ============================================
// References
// ============================================

/// References to supporting data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct References {
    /// Indicator names used in decision
    #[prost(string, repeated, tag="1")]
    pub used_indicators: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Memory case IDs from HelixDB
    #[prost(string, repeated, tag="2")]
    pub memory_case_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Event IDs that influenced decision
    #[prost(string, repeated, tag="3")]
    pub event_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
// ============================================
// Decision
// ============================================

/// Individual decision for an instrument
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decision {
    /// Target instrument
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Trading action
    #[prost(enumeration="Action", tag="2")]
    pub action: i32,
    /// Position sizing
    #[prost(message, optional, tag="3")]
    pub size: ::core::option::Option<Size>,
    /// Order execution plan
    #[prost(message, optional, tag="4")]
    pub order_plan: ::core::option::Option<OrderPlan>,
    /// Risk levels (mandatory - always required)
    #[prost(message, optional, tag="5")]
    pub risk_levels: ::core::option::Option<RiskLevels>,
    /// Strategy family (position type)
    #[prost(enumeration="StrategyFamily", tag="6")]
    pub strategy_family: i32,
    /// Human-readable rationale for the decision
    #[prost(string, tag="7")]
    pub rationale: ::prost::alloc::string::String,
    /// Confidence score \[0.0, 1.0\]
    #[prost(double, tag="8")]
    pub confidence: f64,
    /// Supporting references
    #[prost(message, optional, tag="9")]
    pub references: ::core::option::Option<References>,
    /// Direction of the position
    #[prost(enumeration="Direction", tag="10")]
    pub direction: i32,
    /// Time horizon for the trade
    #[prost(enumeration="TimeHorizon", tag="11")]
    pub time_horizon: i32,
    /// Current thesis state
    #[prost(enumeration="ThesisState", tag="12")]
    pub thesis_state: i32,
    /// Bullish factors supporting the decision
    #[prost(string, repeated, tag="13")]
    pub bullish_factors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Bearish factors considered
    #[prost(string, repeated, tag="14")]
    pub bearish_factors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Option legs for multi-leg strategies (empty for single-leg orders)
    #[prost(message, repeated, tag="15")]
    pub legs: ::prost::alloc::vec::Vec<OptionLeg>,
    /// Net limit price for multi-leg orders (debit positive, credit negative)
    #[prost(double, optional, tag="16")]
    pub net_limit_price: ::core::option::Option<f64>,
}
// ============================================
// DecisionPlan
// ============================================

/// Complete decision plan for a trading cycle
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionPlan {
    /// Unique identifier for this trading cycle
    #[prost(string, tag="1")]
    pub cycle_id: ::prost::alloc::string::String,
    /// Timestamp when the decision was made
    #[prost(message, optional, tag="2")]
    pub as_of_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Trading environment
    #[prost(enumeration="Environment", tag="3")]
    pub environment: i32,
    /// List of decisions for this cycle
    #[prost(message, repeated, tag="4")]
    pub decisions: ::prost::alloc::vec::Vec<Decision>,
    /// Optional portfolio-level notes
    #[prost(string, optional, tag="5")]
    pub portfolio_notes: ::core::option::Option<::prost::alloc::string::String>,
}
// ============================================
// Validation
// ============================================

/// Risk validation result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskValidationResult {
    /// Whether the validation passed
    #[prost(bool, tag="1")]
    pub valid: bool,
    /// Validation errors (blocking issues)
    #[prost(string, repeated, tag="2")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Validation warnings (non-blocking issues)
    #[prost(string, repeated, tag="3")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Calculated risk-reward ratio
    #[prost(double, optional, tag="4")]
    pub risk_reward_ratio: ::core::option::Option<f64>,
}
/// Decision plan validation result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionPlanValidationResult {
    /// Whether the validation passed
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Validated decision plan (if successful)
    #[prost(message, optional, tag="2")]
    pub decision_plan: ::core::option::Option<DecisionPlan>,
    /// Validation errors
    #[prost(string, repeated, tag="3")]
    pub errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Validation warnings
    #[prost(string, repeated, tag="4")]
    pub warnings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
// ============================================
// Payload Messages for Specific Event Types
// ============================================

/// Earnings event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EarningsEventPayload {
    /// Symbol this earnings relates to
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Fiscal quarter (e.g., "Q1", "Q2")
    #[prost(string, tag="2")]
    pub quarter: ::prost::alloc::string::String,
    /// Fiscal year
    #[prost(int32, tag="3")]
    pub year: i32,
    /// Actual EPS reported
    #[prost(double, optional, tag="4")]
    pub eps_actual: ::core::option::Option<f64>,
    /// Expected/consensus EPS
    #[prost(double, optional, tag="5")]
    pub eps_expected: ::core::option::Option<f64>,
    /// EPS surprise percentage ((actual - expected) / expected * 100)
    #[prost(double, optional, tag="6")]
    pub eps_surprise_pct: ::core::option::Option<f64>,
    /// Actual revenue reported (in dollars)
    #[prost(double, optional, tag="7")]
    pub revenue_actual: ::core::option::Option<f64>,
    /// Expected/consensus revenue
    #[prost(double, optional, tag="8")]
    pub revenue_expected: ::core::option::Option<f64>,
    /// Revenue surprise percentage
    #[prost(double, optional, tag="9")]
    pub revenue_surprise_pct: ::core::option::Option<f64>,
    /// Management guidance update
    #[prost(string, optional, tag="10")]
    pub guidance_summary: ::core::option::Option<::prost::alloc::string::String>,
    /// Earnings call transcript available
    #[prost(bool, tag="11")]
    pub transcript_available: bool,
}
/// Macro economic event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MacroEventPayload {
    /// Indicator name (e.g., "Non-Farm Payrolls", "CPI", "GDP")
    #[prost(string, tag="1")]
    pub indicator_name: ::prost::alloc::string::String,
    /// Actual value released
    #[prost(double, tag="2")]
    pub value: f64,
    /// Previous period value
    #[prost(double, optional, tag="3")]
    pub previous_value: ::core::option::Option<f64>,
    /// Expected/consensus value
    #[prost(double, optional, tag="4")]
    pub expected_value: ::core::option::Option<f64>,
    /// Surprise percentage
    #[prost(double, optional, tag="5")]
    pub surprise_pct: ::core::option::Option<f64>,
    /// Unit of measurement
    #[prost(string, tag="6")]
    pub unit: ::prost::alloc::string::String,
    /// Country (default: "US")
    #[prost(string, tag="7")]
    pub country: ::prost::alloc::string::String,
    /// Period this data covers
    #[prost(string, optional, tag="8")]
    pub period: ::core::option::Option<::prost::alloc::string::String>,
}
/// News event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewsEventPayload {
    /// Article headline
    #[prost(string, tag="1")]
    pub headline: ::prost::alloc::string::String,
    /// Article body/summary
    #[prost(string, tag="2")]
    pub body: ::prost::alloc::string::String,
    /// Source publication
    #[prost(string, tag="3")]
    pub source: ::prost::alloc::string::String,
    /// URL to full article
    #[prost(string, optional, tag="4")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Extracted entities (company names, people, products)
    #[prost(message, repeated, tag="5")]
    pub entities: ::prost::alloc::vec::Vec<ExtractedEntity>,
    /// LLM-extracted key insights
    #[prost(string, repeated, tag="6")]
    pub key_insights: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Extracted entity from content
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExtractedEntity {
    /// Entity name as it appears
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Entity type
    ///
    /// "company", "person", "product", "event", "location"
    #[prost(string, tag="2")]
    pub entity_type: ::prost::alloc::string::String,
    /// Resolved ticker symbol (if company)
    #[prost(string, optional, tag="3")]
    pub ticker: ::core::option::Option<::prost::alloc::string::String>,
}
/// Sentiment spike event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SentimentEventPayload {
    /// Platform (Twitter/X, Reddit, StockTwits)
    #[prost(string, tag="1")]
    pub platform: ::prost::alloc::string::String,
    /// Volume of mentions
    #[prost(int64, tag="2")]
    pub mention_count: i64,
    /// Normal average volume
    #[prost(int64, optional, tag="3")]
    pub average_volume: ::core::option::Option<i64>,
    /// Volume z-score
    #[prost(double, optional, tag="4")]
    pub volume_zscore: ::core::option::Option<f64>,
    /// Aggregate sentiment of mentions
    #[prost(enumeration="Sentiment", tag="5")]
    pub aggregate_sentiment: i32,
    /// Time window in minutes
    #[prost(int32, tag="6")]
    pub window_minutes: i32,
}
/// Merger/acquisition event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergerAcquisitionPayload {
    /// Type: "merger", "acquisition", "spinoff", "divestiture"
    #[prost(string, tag="1")]
    pub transaction_type: ::prost::alloc::string::String,
    /// Acquirer symbol (if acquisition)
    #[prost(string, optional, tag="2")]
    pub acquirer_symbol: ::core::option::Option<::prost::alloc::string::String>,
    /// Target symbol (if acquisition)
    #[prost(string, optional, tag="3")]
    pub target_symbol: ::core::option::Option<::prost::alloc::string::String>,
    /// Deal value (if disclosed)
    #[prost(double, optional, tag="4")]
    pub deal_value: ::core::option::Option<f64>,
    /// Currency of deal value
    #[prost(string, tag="5")]
    pub currency: ::prost::alloc::string::String,
    /// Expected close date
    #[prost(string, optional, tag="6")]
    pub expected_close_date: ::core::option::Option<::prost::alloc::string::String>,
    /// Deal status: "announced", "pending", "approved", "closed", "terminated"
    #[prost(string, tag="7")]
    pub status: ::prost::alloc::string::String,
}
/// Analyst rating event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalystRatingPayload {
    /// Analyst firm name
    #[prost(string, tag="1")]
    pub firm: ::prost::alloc::string::String,
    /// Analyst name (if available)
    #[prost(string, optional, tag="2")]
    pub analyst_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Previous rating (if upgrade/downgrade)
    #[prost(string, optional, tag="3")]
    pub previous_rating: ::core::option::Option<::prost::alloc::string::String>,
    /// New rating
    #[prost(string, tag="4")]
    pub new_rating: ::prost::alloc::string::String,
    /// Previous price target
    #[prost(double, optional, tag="5")]
    pub previous_target: ::core::option::Option<f64>,
    /// New price target
    #[prost(double, optional, tag="6")]
    pub new_target: ::core::option::Option<f64>,
    /// Action type: "initiated", "upgrade", "downgrade", "reiterated"
    #[prost(string, tag="7")]
    pub action_type: ::prost::alloc::string::String,
}
/// Regulatory event payload
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegulatoryPayload {
    /// Regulatory body (FDA, SEC, FTC, DOJ, etc.)
    #[prost(string, tag="1")]
    pub regulatory_body: ::prost::alloc::string::String,
    /// Action type (approval, rejection, investigation, settlement, etc.)
    #[prost(string, tag="2")]
    pub action_type: ::prost::alloc::string::String,
    /// Product or matter name (if applicable)
    #[prost(string, optional, tag="3")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Decision or status
    #[prost(string, tag="4")]
    pub decision: ::prost::alloc::string::String,
    /// Next steps or timeline
    #[prost(string, optional, tag="5")]
    pub next_steps: ::core::option::Option<::prost::alloc::string::String>,
}
/// Dividend event payload
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DividendPayload {
    /// Dividend amount per share
    #[prost(double, tag="1")]
    pub amount: f64,
    /// Currency
    #[prost(string, tag="2")]
    pub currency: ::prost::alloc::string::String,
    /// Ex-dividend date
    #[prost(string, tag="3")]
    pub ex_date: ::prost::alloc::string::String,
    /// Record date
    #[prost(string, optional, tag="4")]
    pub record_date: ::core::option::Option<::prost::alloc::string::String>,
    /// Payment date
    #[prost(string, optional, tag="5")]
    pub payment_date: ::core::option::Option<::prost::alloc::string::String>,
    /// Dividend type: "regular", "special", "variable"
    #[prost(string, tag="6")]
    pub dividend_type: ::prost::alloc::string::String,
    /// Year-over-year change percentage
    #[prost(double, optional, tag="7")]
    pub yoy_change_pct: ::core::option::Option<f64>,
}
/// Stock split event payload
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SplitPayload {
    /// Split ratio numerator (e.g., 4 for 4:1)
    #[prost(int32, tag="1")]
    pub split_from: i32,
    /// Split ratio denominator (e.g., 1 for 4:1)
    #[prost(int32, tag="2")]
    pub split_to: i32,
    /// Effective date
    #[prost(string, tag="3")]
    pub effective_date: ::prost::alloc::string::String,
    /// Announcement date
    #[prost(string, optional, tag="4")]
    pub announcement_date: ::core::option::Option<::prost::alloc::string::String>,
}
// ============================================
// External Event (Main Message)
// ============================================

/// A discrete external event
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalEvent {
    /// Unique identifier (UUID v4)
    #[prost(string, tag="1")]
    pub event_id: ::prost::alloc::string::String,
    /// Category of event
    #[prost(enumeration="EventType", tag="2")]
    pub event_type: i32,
    /// When the event occurred
    #[prost(message, optional, tag="3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Affected instrument IDs (tickers)
    #[prost(string, repeated, tag="4")]
    pub related_instrument_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Data source
    #[prost(enumeration="DataSource", tag="5")]
    pub source: i32,
    /// Headline or summary (for quick display)
    #[prost(string, optional, tag="6")]
    pub headline: ::core::option::Option<::prost::alloc::string::String>,
    // ============================================
    // Computed Scores (from extraction pipeline)
    // ============================================

    /// Sentiment score (-1.0 bearish to 1.0 bullish)
    #[prost(double, optional, tag="20")]
    pub sentiment_score: ::core::option::Option<f64>,
    /// Importance/relevance score (0.0 to 1.0)
    #[prost(double, optional, tag="21")]
    pub importance_score: ::core::option::Option<f64>,
    /// Surprise score (-1.0 big miss to 1.0 big beat)
    #[prost(double, optional, tag="22")]
    pub surprise_score: ::core::option::Option<f64>,
    /// Confidence in extraction (0.0 to 1.0)
    #[prost(double, optional, tag="23")]
    pub confidence: ::core::option::Option<f64>,
    // ============================================
    // Metadata
    // ============================================

    /// When the event was processed/extracted
    #[prost(message, optional, tag="30")]
    pub processed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Original content (for reference/debugging)
    #[prost(string, optional, tag="31")]
    pub original_content: ::core::option::Option<::prost::alloc::string::String>,
    /// Event payload (structure varies by event_type)
    /// Using oneof for type-safe payloads
    #[prost(oneof="external_event::Payload", tags="10, 11, 12, 13, 14, 15, 16, 17, 18, 19")]
    pub payload: ::core::option::Option<external_event::Payload>,
}
/// Nested message and enum types in `ExternalEvent`.
pub mod external_event {
    /// Event payload (structure varies by event_type)
    /// Using oneof for type-safe payloads
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="10")]
        Earnings(super::EarningsEventPayload),
        #[prost(message, tag="11")]
        Macro(super::MacroEventPayload),
        #[prost(message, tag="12")]
        News(super::NewsEventPayload),
        #[prost(message, tag="13")]
        SentimentSpike(super::SentimentEventPayload),
        #[prost(message, tag="14")]
        MergerAcquisition(super::MergerAcquisitionPayload),
        #[prost(message, tag="15")]
        AnalystRating(super::AnalystRatingPayload),
        #[prost(message, tag="16")]
        Regulatory(super::RegulatoryPayload),
        #[prost(message, tag="17")]
        Dividend(super::DividendPayload),
        #[prost(message, tag="18")]
        Split(super::SplitPayload),
        /// Fallback for other types
        #[prost(message, tag="19")]
        GenericPayload(::prost_types::Struct),
    }
}
// ============================================
// Event Collections
// ============================================

/// Collection of external events
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalEventList {
    /// Events in the collection
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<ExternalEvent>,
    /// Total count (may exceed list if paginated)
    #[prost(int32, tag="2")]
    pub total_count: i32,
    /// Pagination cursor for next page
    #[prost(string, optional, tag="3")]
    pub next_cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// Event query request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventQueryRequest {
    /// Filter by event types
    #[prost(enumeration="EventType", repeated, tag="1")]
    pub event_types: ::prost::alloc::vec::Vec<i32>,
    /// Filter by instrument IDs
    #[prost(string, repeated, tag="2")]
    pub instrument_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Start time (inclusive)
    #[prost(message, optional, tag="3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// End time (exclusive)
    #[prost(message, optional, tag="4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Maximum events to return
    #[prost(int32, tag="5")]
    pub limit: i32,
    /// Pagination cursor
    #[prost(string, optional, tag="6")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Minimum importance score
    #[prost(double, optional, tag="7")]
    pub min_importance: ::core::option::Option<f64>,
}
// ============================================
// Event Type Enumeration
// ============================================

/// Category of external event
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    Unspecified = 0,
    /// Earnings report
    Earnings = 1,
    /// Forward guidance update
    Guidance = 2,
    /// Macro economic release
    Macro = 3,
    /// General news
    News = 4,
    /// Social/sentiment volume spike
    SentimentSpike = 5,
    /// SEC filing (10-K, 10-Q, 8-K)
    SecFiling = 6,
    /// Dividend announcement
    Dividend = 7,
    /// Stock split
    Split = 8,
    /// Merger and acquisition
    MAndA = 9,
    /// Analyst rating change
    AnalystRating = 10,
    /// Conference/investor day
    Conference = 11,
    /// Product launch
    ProductLaunch = 12,
    /// Regulatory decision
    Regulatory = 13,
    /// Executive appointment/departure
    ExecutiveChange = 14,
    /// Legal/litigation
    Legal = 15,
    /// Other/unclassified
    Other = 16,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
            Self::Earnings => "EVENT_TYPE_EARNINGS",
            Self::Guidance => "EVENT_TYPE_GUIDANCE",
            Self::Macro => "EVENT_TYPE_MACRO",
            Self::News => "EVENT_TYPE_NEWS",
            Self::SentimentSpike => "EVENT_TYPE_SENTIMENT_SPIKE",
            Self::SecFiling => "EVENT_TYPE_SEC_FILING",
            Self::Dividend => "EVENT_TYPE_DIVIDEND",
            Self::Split => "EVENT_TYPE_SPLIT",
            Self::MAndA => "EVENT_TYPE_M_AND_A",
            Self::AnalystRating => "EVENT_TYPE_ANALYST_RATING",
            Self::Conference => "EVENT_TYPE_CONFERENCE",
            Self::ProductLaunch => "EVENT_TYPE_PRODUCT_LAUNCH",
            Self::Regulatory => "EVENT_TYPE_REGULATORY",
            Self::ExecutiveChange => "EVENT_TYPE_EXECUTIVE_CHANGE",
            Self::Legal => "EVENT_TYPE_LEGAL",
            Self::Other => "EVENT_TYPE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVENT_TYPE_EARNINGS" => Some(Self::Earnings),
            "EVENT_TYPE_GUIDANCE" => Some(Self::Guidance),
            "EVENT_TYPE_MACRO" => Some(Self::Macro),
            "EVENT_TYPE_NEWS" => Some(Self::News),
            "EVENT_TYPE_SENTIMENT_SPIKE" => Some(Self::SentimentSpike),
            "EVENT_TYPE_SEC_FILING" => Some(Self::SecFiling),
            "EVENT_TYPE_DIVIDEND" => Some(Self::Dividend),
            "EVENT_TYPE_SPLIT" => Some(Self::Split),
            "EVENT_TYPE_M_AND_A" => Some(Self::MAndA),
            "EVENT_TYPE_ANALYST_RATING" => Some(Self::AnalystRating),
            "EVENT_TYPE_CONFERENCE" => Some(Self::Conference),
            "EVENT_TYPE_PRODUCT_LAUNCH" => Some(Self::ProductLaunch),
            "EVENT_TYPE_REGULATORY" => Some(Self::Regulatory),
            "EVENT_TYPE_EXECUTIVE_CHANGE" => Some(Self::ExecutiveChange),
            "EVENT_TYPE_LEGAL" => Some(Self::Legal),
            "EVENT_TYPE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Data source for external events
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataSource {
    Unspecified = 0,
    /// Reserved (formerly FMP)
    Reserved1 = 1,
    /// Alpha Vantage
    AlphaVantage = 2,
    /// Reserved (formerly Polygon)
    Reserved3 = 3,
    /// Benzinga
    Benzinga = 4,
    /// SEC EDGAR
    SecEdgar = 5,
    /// Social media aggregation
    Social = 6,
    /// Internal system-generated
    Internal = 7,
    /// Alpaca Markets
    Alpaca = 8,
}
impl DataSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_SOURCE_UNSPECIFIED",
            Self::Reserved1 => "DATA_SOURCE_RESERVED_1",
            Self::AlphaVantage => "DATA_SOURCE_ALPHA_VANTAGE",
            Self::Reserved3 => "DATA_SOURCE_RESERVED_3",
            Self::Benzinga => "DATA_SOURCE_BENZINGA",
            Self::SecEdgar => "DATA_SOURCE_SEC_EDGAR",
            Self::Social => "DATA_SOURCE_SOCIAL",
            Self::Internal => "DATA_SOURCE_INTERNAL",
            Self::Alpaca => "DATA_SOURCE_ALPACA",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_SOURCE_RESERVED_1" => Some(Self::Reserved1),
            "DATA_SOURCE_ALPHA_VANTAGE" => Some(Self::AlphaVantage),
            "DATA_SOURCE_RESERVED_3" => Some(Self::Reserved3),
            "DATA_SOURCE_BENZINGA" => Some(Self::Benzinga),
            "DATA_SOURCE_SEC_EDGAR" => Some(Self::SecEdgar),
            "DATA_SOURCE_SOCIAL" => Some(Self::Social),
            "DATA_SOURCE_INTERNAL" => Some(Self::Internal),
            "DATA_SOURCE_ALPACA" => Some(Self::Alpaca),
            _ => None,
        }
    }
}
/// Sentiment classification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Sentiment {
    Unspecified = 0,
    Bullish = 1,
    Bearish = 2,
    Neutral = 3,
}
impl Sentiment {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SENTIMENT_UNSPECIFIED",
            Self::Bullish => "SENTIMENT_BULLISH",
            Self::Bearish => "SENTIMENT_BEARISH",
            Self::Neutral => "SENTIMENT_NEUTRAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SENTIMENT_UNSPECIFIED" => Some(Self::Unspecified),
            "SENTIMENT_BULLISH" => Some(Self::Bullish),
            "SENTIMENT_BEARISH" => Some(Self::Bearish),
            "SENTIMENT_NEUTRAL" => Some(Self::Neutral),
            _ => None,
        }
    }
}
/// Individual constraint check result
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstraintCheck {
    /// Name of the constraint
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Result of the check
    #[prost(enumeration="ConstraintResult", tag="2")]
    pub result: i32,
    /// Description of the constraint
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Actual value that was checked
    #[prost(double, optional, tag="4")]
    pub actual_value: ::core::option::Option<f64>,
    /// Threshold that was applied
    #[prost(double, optional, tag="5")]
    pub threshold: ::core::option::Option<f64>,
}
/// Request to validate a decision plan against constraints
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckConstraintsRequest {
    /// Decision plan to validate
    #[prost(message, optional, tag="1")]
    pub decision_plan: ::core::option::Option<DecisionPlan>,
    /// Current account state
    #[prost(message, optional, tag="2")]
    pub account_state: ::core::option::Option<AccountState>,
    /// Current positions
    #[prost(message, repeated, tag="3")]
    pub positions: ::prost::alloc::vec::Vec<Position>,
}
/// Response from constraint validation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckConstraintsResponse {
    /// Overall result
    #[prost(bool, tag="1")]
    pub approved: bool,
    /// Individual constraint results
    #[prost(message, repeated, tag="2")]
    pub checks: ::prost::alloc::vec::Vec<ConstraintCheck>,
    /// Detailed violations (when not approved)
    #[prost(message, repeated, tag="3")]
    pub violations: ::prost::alloc::vec::Vec<ConstraintViolation>,
    /// Timestamp of validation
    #[prost(message, optional, tag="4")]
    pub validated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Rejection reason (if not approved)
    #[prost(string, optional, tag="5")]
    pub rejection_reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Detailed constraint violation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConstraintViolation {
    /// Violation code (e.g., "MAX_POSITION_SIZE", "INSUFFICIENT_MARGIN")
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    /// Severity level
    #[prost(enumeration="ViolationSeverity", tag="2")]
    pub severity: i32,
    /// Human-readable description
    #[prost(string, tag="3")]
    pub message: ::prost::alloc::string::String,
    /// Instrument that violated (if applicable)
    #[prost(string, optional, tag="4")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Field path that violated (e.g., "size.quantity")
    #[prost(string, optional, tag="5")]
    pub field_path: ::core::option::Option<::prost::alloc::string::String>,
    /// Observed value that triggered violation
    #[prost(double, optional, tag="6")]
    pub observed_value: ::core::option::Option<f64>,
    /// Limit that was exceeded
    #[prost(double, optional, tag="7")]
    pub limit_value: ::core::option::Option<f64>,
    /// Constraint name that was violated
    #[prost(string, tag="8")]
    pub constraint_name: ::prost::alloc::string::String,
}
// ============================================
// Account State
// ============================================

/// Current account state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountState {
    /// Account identifier
    #[prost(string, tag="1")]
    pub account_id: ::prost::alloc::string::String,
    /// Total account equity
    #[prost(double, tag="2")]
    pub equity: f64,
    /// Available cash for trading
    #[prost(double, tag="3")]
    pub buying_power: f64,
    /// Current margin used
    #[prost(double, tag="4")]
    pub margin_used: f64,
    /// Day trade count (for PDT rule) - used in rolling 5-day window
    #[prost(int32, tag="5")]
    pub day_trade_count: i32,
    /// Whether pattern day trader rules apply (account flagged as PDT)
    #[prost(bool, tag="6")]
    pub is_pdt_restricted: bool,
    /// Timestamp of state snapshot
    #[prost(message, optional, tag="7")]
    pub as_of: ::core::option::Option<::prost_types::Timestamp>,
    /// Previous day's equity (used for $25k PDT threshold check)
    #[prost(double, tag="8")]
    pub last_equity: f64,
    /// Day trading buying power (4x equity for PDT accounts)
    #[prost(double, tag="9")]
    pub daytrading_buying_power: f64,
    /// Remaining day trades available (max 3 when under $25k)
    #[prost(int32, tag="10")]
    pub remaining_day_trades: i32,
    /// Whether account is under the $25k PDT threshold
    #[prost(bool, tag="11")]
    pub under_pdt_threshold: bool,
}
// ============================================
// Positions
// ============================================

/// Current position
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    /// Instrument
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Quantity held (signed: positive=long, negative=short)
    #[prost(int32, tag="2")]
    pub quantity: i32,
    /// Average entry price
    #[prost(double, tag="3")]
    pub avg_entry_price: f64,
    /// Current market value
    #[prost(double, tag="4")]
    pub market_value: f64,
    /// Unrealized P&L
    #[prost(double, tag="5")]
    pub unrealized_pnl: f64,
    /// Unrealized P&L percentage
    #[prost(double, tag="6")]
    pub unrealized_pnl_pct: f64,
    /// Cost basis
    #[prost(double, tag="7")]
    pub cost_basis: f64,
}
/// Request to submit an order
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOrderRequest {
    /// Instrument to trade
    #[prost(message, optional, tag="1")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Buy or sell
    #[prost(enumeration="OrderSide", tag="2")]
    pub side: i32,
    /// Quantity
    #[prost(int32, tag="3")]
    pub quantity: i32,
    /// Order type
    #[prost(enumeration="OrderType", tag="4")]
    pub order_type: i32,
    /// Limit price (required for limit orders)
    #[prost(double, optional, tag="5")]
    pub limit_price: ::core::option::Option<f64>,
    /// Time in force
    #[prost(enumeration="TimeInForce", tag="6")]
    pub time_in_force: i32,
    /// Client order ID for tracking
    #[prost(string, tag="7")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Reference to decision cycle
    #[prost(string, tag="8")]
    pub cycle_id: ::prost::alloc::string::String,
}
/// Response from order submission
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitOrderResponse {
    /// Broker-assigned order ID
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
    /// Client order ID (echoed back)
    #[prost(string, tag="2")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Current order status
    #[prost(enumeration="OrderStatus", tag="3")]
    pub status: i32,
    /// Submission timestamp
    #[prost(message, optional, tag="4")]
    pub submitted_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Error message if rejected
    #[prost(string, optional, tag="5")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Order execution acknowledgment
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionAck {
    /// Decision cycle ID
    #[prost(string, tag="1")]
    pub cycle_id: ::prost::alloc::string::String,
    /// Environment the execution ran in
    #[prost(enumeration="Environment", tag="2")]
    pub environment: i32,
    /// Timestamp of acknowledgment
    #[prost(message, optional, tag="3")]
    pub ack_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Orders that were executed
    #[prost(message, repeated, tag="4")]
    pub orders: ::prost::alloc::vec::Vec<OrderState>,
    /// Errors encountered during execution
    #[prost(message, repeated, tag="5")]
    pub errors: ::prost::alloc::vec::Vec<ExecutionError>,
}
/// Complete order state for tracking
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderState {
    /// Internal order ID
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
    /// Broker-assigned order ID
    #[prost(string, tag="2")]
    pub broker_order_id: ::prost::alloc::string::String,
    /// Client order ID
    #[prost(string, tag="3")]
    pub client_order_id: ::prost::alloc::string::String,
    /// Whether this is a multi-leg order
    #[prost(bool, tag="4")]
    pub is_multi_leg: bool,
    /// Leg states (for multi-leg orders)
    #[prost(message, repeated, tag="5")]
    pub legs: ::prost::alloc::vec::Vec<OrderLegState>,
    /// Current status
    #[prost(enumeration="OrderStatus", tag="6")]
    pub status: i32,
    /// Order side
    #[prost(enumeration="OrderSide", tag="7")]
    pub side: i32,
    /// Order type
    #[prost(enumeration="OrderType", tag="8")]
    pub order_type: i32,
    /// Instrument (for single-leg orders)
    #[prost(message, optional, tag="9")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Requested quantity
    #[prost(int32, tag="10")]
    pub requested_quantity: i32,
    /// Filled quantity
    #[prost(int32, tag="11")]
    pub filled_quantity: i32,
    /// Average fill price
    #[prost(double, tag="12")]
    pub avg_fill_price: f64,
    /// Limit price (if applicable)
    #[prost(double, optional, tag="13")]
    pub limit_price: ::core::option::Option<f64>,
    /// Stop price (if applicable)
    #[prost(double, optional, tag="14")]
    pub stop_price: ::core::option::Option<f64>,
    /// Time in force
    #[prost(enumeration="TimeInForce", tag="15")]
    pub time_in_force: i32,
    /// Submission timestamp
    #[prost(message, optional, tag="16")]
    pub submitted_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag="17")]
    pub last_update_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Commission charged
    #[prost(double, tag="18")]
    pub commission: f64,
    /// Reference to decision cycle
    #[prost(string, tag="19")]
    pub cycle_id: ::prost::alloc::string::String,
    /// Status message from broker
    #[prost(string, tag="20")]
    pub status_message: ::prost::alloc::string::String,
}
/// State of a single leg in a multi-leg order
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderLegState {
    /// Leg identifier within the order
    #[prost(string, tag="1")]
    pub leg_id: ::prost::alloc::string::String,
    /// Instrument for this leg
    #[prost(message, optional, tag="2")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Side for this leg (BUY or SELL)
    #[prost(enumeration="OrderSide", tag="3")]
    pub side: i32,
    /// Requested quantity for this leg
    #[prost(int32, tag="4")]
    pub quantity: i32,
    /// Order type for this leg
    #[prost(enumeration="OrderType", tag="5")]
    pub order_type: i32,
    /// Limit price for this leg (if applicable)
    #[prost(double, optional, tag="6")]
    pub limit_price: ::core::option::Option<f64>,
    /// Status of this leg
    #[prost(enumeration="OrderStatus", tag="7")]
    pub status: i32,
    /// Filled quantity for this leg
    #[prost(int32, tag="8")]
    pub filled_quantity: i32,
    /// Average fill price for this leg
    #[prost(double, tag="9")]
    pub avg_fill_price: f64,
    /// Last update timestamp for this leg
    #[prost(message, optional, tag="10")]
    pub last_update_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Execution error
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecutionError {
    /// Error code
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    /// Human-readable error message
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Instrument that caused the error (if applicable)
    #[prost(string, optional, tag="3")]
    pub instrument_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Order ID that caused the error (if applicable)
    #[prost(string, optional, tag="4")]
    pub order_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Whether this error is retryable
    #[prost(bool, tag="5")]
    pub retryable: bool,
    /// Suggested action
    #[prost(string, tag="6")]
    pub suggested_action: ::prost::alloc::string::String,
}
/// Request to get order state
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOrderStateRequest {
    /// Order ID to query (can be broker order ID or internal order ID)
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
}
/// Response with order state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrderStateResponse {
    /// Order ID
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
    /// Broker order ID
    #[prost(string, tag="2")]
    pub broker_order_id: ::prost::alloc::string::String,
    /// Instrument
    #[prost(message, optional, tag="3")]
    pub instrument: ::core::option::Option<Instrument>,
    /// Current status
    #[prost(enumeration="OrderStatus", tag="4")]
    pub status: i32,
    /// Order side
    #[prost(enumeration="OrderSide", tag="5")]
    pub side: i32,
    /// Order type
    #[prost(enumeration="OrderType", tag="6")]
    pub order_type: i32,
    /// Requested quantity
    #[prost(int32, tag="7")]
    pub requested_quantity: i32,
    /// Filled quantity
    #[prost(int32, tag="8")]
    pub filled_quantity: i32,
    /// Average fill price
    #[prost(double, tag="9")]
    pub avg_fill_price: f64,
    /// Limit price (if applicable)
    #[prost(double, optional, tag="10")]
    pub limit_price: ::core::option::Option<f64>,
    /// Stop price (if applicable)
    #[prost(double, optional, tag="11")]
    pub stop_price: ::core::option::Option<f64>,
    /// Submission timestamp
    #[prost(message, optional, tag="12")]
    pub submitted_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update timestamp
    #[prost(message, optional, tag="13")]
    pub last_update_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Status message from broker
    #[prost(string, tag="14")]
    pub status_message: ::prost::alloc::string::String,
}
/// Request to cancel an order
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelOrderRequest {
    /// Order ID to cancel (can be broker order ID or internal order ID)
    #[prost(string, tag="1")]
    pub order_id: ::prost::alloc::string::String,
}
/// Response from cancel request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CancelOrderResponse {
    /// Whether cancel request was accepted
    #[prost(bool, tag="1")]
    pub accepted: bool,
    /// Order ID that was canceled
    #[prost(string, tag="2")]
    pub order_id: ::prost::alloc::string::String,
    /// Current order status after cancel request
    #[prost(enumeration="OrderStatus", tag="3")]
    pub status: i32,
    /// Error message if cancel was rejected
    #[prost(string, optional, tag="4")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request to stream executions
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamExecutionsRequest {
    /// Filter by cycle ID (optional)
    #[prost(string, optional, tag="1")]
    pub cycle_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by order IDs (optional)
    #[prost(string, repeated, tag="2")]
    pub order_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response with execution update (streamed)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamExecutionsResponse {
    /// Execution acknowledgment
    #[prost(message, optional, tag="1")]
    pub execution: ::core::option::Option<ExecutionAck>,
}
/// Request for account state
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAccountStateRequest {
    /// Account ID (uses default if not specified)
    #[prost(string, optional, tag="1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response with account state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountStateResponse {
    /// Current account state
    #[prost(message, optional, tag="1")]
    pub account_state: ::core::option::Option<AccountState>,
}
/// Request for positions
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPositionsRequest {
    /// Account ID (uses default if not specified)
    #[prost(string, optional, tag="1")]
    pub account_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by symbols (optional)
    #[prost(string, repeated, tag="2")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response with positions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPositionsResponse {
    /// Current positions
    #[prost(message, repeated, tag="1")]
    pub positions: ::prost::alloc::vec::Vec<Position>,
    /// Timestamp of snapshot
    #[prost(message, optional, tag="2")]
    pub as_of: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================
// Constraint Check
// ============================================

/// Result of a constraint check
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConstraintResult {
    Unspecified = 0,
    Pass = 1,
    Fail = 2,
    Warn = 3,
}
impl ConstraintResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSTRAINT_RESULT_UNSPECIFIED",
            Self::Pass => "CONSTRAINT_RESULT_PASS",
            Self::Fail => "CONSTRAINT_RESULT_FAIL",
            Self::Warn => "CONSTRAINT_RESULT_WARN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSTRAINT_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSTRAINT_RESULT_PASS" => Some(Self::Pass),
            "CONSTRAINT_RESULT_FAIL" => Some(Self::Fail),
            "CONSTRAINT_RESULT_WARN" => Some(Self::Warn),
            _ => None,
        }
    }
}
/// Severity of constraint violation
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ViolationSeverity {
    Unspecified = 0,
    /// Informational, does not block
    Info = 1,
    /// Warning, may proceed with caution
    Warning = 2,
    /// Error, blocks execution
    Error = 3,
    /// Critical, requires immediate attention
    Critical = 4,
}
impl ViolationSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VIOLATION_SEVERITY_UNSPECIFIED",
            Self::Info => "VIOLATION_SEVERITY_INFO",
            Self::Warning => "VIOLATION_SEVERITY_WARNING",
            Self::Error => "VIOLATION_SEVERITY_ERROR",
            Self::Critical => "VIOLATION_SEVERITY_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VIOLATION_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "VIOLATION_SEVERITY_INFO" => Some(Self::Info),
            "VIOLATION_SEVERITY_WARNING" => Some(Self::Warning),
            "VIOLATION_SEVERITY_ERROR" => Some(Self::Error),
            "VIOLATION_SEVERITY_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
// ============================================
// Order Execution
// ============================================

/// Order status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderStatus {
    Unspecified = 0,
    /// Order created but not yet sent to broker
    New = 1,
    /// Sent to broker, awaiting acknowledgment
    Pending = 2,
    /// Accepted by broker
    Accepted = 3,
    /// Partially filled
    PartialFill = 4,
    /// Completely filled
    Filled = 5,
    /// Cancelled by user or system
    Cancelled = 6,
    /// Rejected by broker
    Rejected = 7,
    /// Expired (e.g., DAY order at close)
    Expired = 8,
}
impl OrderStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_STATUS_UNSPECIFIED",
            Self::New => "ORDER_STATUS_NEW",
            Self::Pending => "ORDER_STATUS_PENDING",
            Self::Accepted => "ORDER_STATUS_ACCEPTED",
            Self::PartialFill => "ORDER_STATUS_PARTIAL_FILL",
            Self::Filled => "ORDER_STATUS_FILLED",
            Self::Cancelled => "ORDER_STATUS_CANCELLED",
            Self::Rejected => "ORDER_STATUS_REJECTED",
            Self::Expired => "ORDER_STATUS_EXPIRED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_STATUS_NEW" => Some(Self::New),
            "ORDER_STATUS_PENDING" => Some(Self::Pending),
            "ORDER_STATUS_ACCEPTED" => Some(Self::Accepted),
            "ORDER_STATUS_PARTIAL_FILL" => Some(Self::PartialFill),
            "ORDER_STATUS_FILLED" => Some(Self::Filled),
            "ORDER_STATUS_CANCELLED" => Some(Self::Cancelled),
            "ORDER_STATUS_REJECTED" => Some(Self::Rejected),
            "ORDER_STATUS_EXPIRED" => Some(Self::Expired),
            _ => None,
        }
    }
}
/// Order side
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderSide {
    Unspecified = 0,
    Buy = 1,
    Sell = 2,
}
impl OrderSide {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_SIDE_UNSPECIFIED",
            Self::Buy => "ORDER_SIDE_BUY",
            Self::Sell => "ORDER_SIDE_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_SIDE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_SIDE_BUY" => Some(Self::Buy),
            "ORDER_SIDE_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
// ============================================
// Quote Data
// ============================================

/// Real-time quote for a symbol
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quote {
    /// Symbol (e.g., "AAPL")
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Best bid price
    #[prost(double, tag="2")]
    pub bid: f64,
    /// Best ask price
    #[prost(double, tag="3")]
    pub ask: f64,
    /// Bid size (shares/contracts)
    #[prost(int32, tag="4")]
    pub bid_size: i32,
    /// Ask size (shares/contracts)
    #[prost(int32, tag="5")]
    pub ask_size: i32,
    /// Last trade price
    #[prost(double, tag="6")]
    pub last: f64,
    /// Last trade size
    #[prost(int32, tag="7")]
    pub last_size: i32,
    /// Cumulative volume
    #[prost(int64, tag="8")]
    pub volume: i64,
    /// Quote timestamp
    #[prost(message, optional, tag="9")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================
// OHLCV Bar
// ============================================

/// OHLCV candlestick bar
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bar {
    /// Symbol
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Bar open time
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Bar timeframe in minutes (1, 5, 15, 60, 240, 1440)
    #[prost(int32, tag="3")]
    pub timeframe_minutes: i32,
    /// Open price
    #[prost(double, tag="4")]
    pub open: f64,
    /// High price
    #[prost(double, tag="5")]
    pub high: f64,
    /// Low price
    #[prost(double, tag="6")]
    pub low: f64,
    /// Close price
    #[prost(double, tag="7")]
    pub close: f64,
    /// Volume
    #[prost(int64, tag="8")]
    pub volume: i64,
    /// VWAP (volume-weighted average price)
    #[prost(double, optional, tag="9")]
    pub vwap: ::core::option::Option<f64>,
    /// Number of trades
    #[prost(int32, optional, tag="10")]
    pub trade_count: ::core::option::Option<i32>,
}
// ============================================
// Market Snapshot
// ============================================

/// Complete market snapshot for a symbol
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SymbolSnapshot {
    /// Symbol
    #[prost(string, tag="1")]
    pub symbol: ::prost::alloc::string::String,
    /// Current quote
    #[prost(message, optional, tag="2")]
    pub quote: ::core::option::Option<Quote>,
    /// Latest completed bars (multiple timeframes)
    #[prost(message, repeated, tag="3")]
    pub bars: ::prost::alloc::vec::Vec<Bar>,
    /// Market status
    #[prost(enumeration="MarketStatus", tag="4")]
    pub market_status: i32,
    /// Daily high
    #[prost(double, tag="5")]
    pub day_high: f64,
    /// Daily low
    #[prost(double, tag="6")]
    pub day_low: f64,
    /// Previous close
    #[prost(double, tag="7")]
    pub prev_close: f64,
    /// Today's open
    #[prost(double, tag="8")]
    pub open: f64,
    /// Snapshot timestamp
    #[prost(message, optional, tag="9")]
    pub as_of: ::core::option::Option<::prost_types::Timestamp>,
}
/// Full market snapshot for multiple symbols
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarketSnapshot {
    /// Trading environment
    #[prost(enumeration="Environment", tag="1")]
    pub environment: i32,
    /// Snapshot timestamp
    #[prost(message, optional, tag="2")]
    pub as_of: ::core::option::Option<::prost_types::Timestamp>,
    /// Market status (overall)
    #[prost(enumeration="MarketStatus", tag="3")]
    pub market_status: i32,
    /// Current regime classification
    #[prost(enumeration="Regime", tag="4")]
    pub regime: i32,
    /// Symbol snapshots
    #[prost(message, repeated, tag="5")]
    pub symbols: ::prost::alloc::vec::Vec<SymbolSnapshot>,
}
// ============================================
// Option Chain
// ============================================

/// Option quote
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionQuote {
    /// Option contract
    #[prost(message, optional, tag="1")]
    pub contract: ::core::option::Option<OptionContract>,
    /// Quote data
    #[prost(message, optional, tag="2")]
    pub quote: ::core::option::Option<Quote>,
    /// Implied volatility
    #[prost(double, optional, tag="3")]
    pub implied_volatility: ::core::option::Option<f64>,
    /// Delta
    #[prost(double, optional, tag="4")]
    pub delta: ::core::option::Option<f64>,
    /// Gamma
    #[prost(double, optional, tag="5")]
    pub gamma: ::core::option::Option<f64>,
    /// Theta
    #[prost(double, optional, tag="6")]
    pub theta: ::core::option::Option<f64>,
    /// Vega
    #[prost(double, optional, tag="7")]
    pub vega: ::core::option::Option<f64>,
    /// Rho
    #[prost(double, optional, tag="8")]
    pub rho: ::core::option::Option<f64>,
    /// Open interest
    #[prost(int32, tag="9")]
    pub open_interest: i32,
}
/// Option chain for an underlying
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OptionChain {
    /// Underlying symbol
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Underlying price
    #[prost(double, tag="2")]
    pub underlying_price: f64,
    /// Option quotes
    #[prost(message, repeated, tag="3")]
    pub options: ::prost::alloc::vec::Vec<OptionQuote>,
    /// Chain timestamp
    #[prost(message, optional, tag="4")]
    pub as_of: ::core::option::Option<::prost_types::Timestamp>,
}
// ============================================
// Streaming Service
// ============================================

/// Request to subscribe to market data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubscribeMarketDataRequest {
    /// Symbols to subscribe to
    #[prost(string, repeated, tag="1")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Include option chains
    #[prost(bool, tag="2")]
    pub include_options: bool,
    /// Bar timeframes to include (in minutes)
    #[prost(int32, repeated, tag="3")]
    pub bar_timeframes: ::prost::alloc::vec::Vec<i32>,
}
/// Market data update (streamed response)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeMarketDataResponse {
    /// Update type
    #[prost(oneof="subscribe_market_data_response::Update", tags="1, 2, 3, 4")]
    pub update: ::core::option::Option<subscribe_market_data_response::Update>,
}
/// Nested message and enum types in `SubscribeMarketDataResponse`.
pub mod subscribe_market_data_response {
    /// Update type
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Update {
        #[prost(message, tag="1")]
        Quote(super::Quote),
        #[prost(message, tag="2")]
        Bar(super::Bar),
        #[prost(message, tag="3")]
        OptionQuote(super::OptionQuote),
        #[prost(message, tag="4")]
        Snapshot(super::SymbolSnapshot),
    }
}
/// Request for snapshot
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSnapshotRequest {
    /// Symbols to get snapshot for
    #[prost(string, repeated, tag="1")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Include bars
    #[prost(bool, tag="2")]
    pub include_bars: bool,
    /// Bar timeframes to include
    #[prost(int32, repeated, tag="3")]
    pub bar_timeframes: ::prost::alloc::vec::Vec<i32>,
}
/// Response with snapshot
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnapshotResponse {
    /// Market snapshot
    #[prost(message, optional, tag="1")]
    pub snapshot: ::core::option::Option<MarketSnapshot>,
}
/// Request for option chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOptionChainRequest {
    /// Underlying symbol
    #[prost(string, tag="1")]
    pub underlying: ::prost::alloc::string::String,
    /// Expiration dates to include (YYYY-MM-DD format, empty for all)
    #[prost(string, repeated, tag="2")]
    pub expirations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Strike range (min)
    #[prost(double, optional, tag="3")]
    pub min_strike: ::core::option::Option<f64>,
    /// Strike range (max)
    #[prost(double, optional, tag="4")]
    pub max_strike: ::core::option::Option<f64>,
}
/// Response with option chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOptionChainResponse {
    /// Option chain
    #[prost(message, optional, tag="1")]
    pub chain: ::core::option::Option<OptionChain>,
}
include!("cream.v1.tonic.rs");
// @@protoc_insertion_point(module)